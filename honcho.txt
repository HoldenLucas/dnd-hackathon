# SDK and API Compatibility Guide
Source: https://docs.honcho.dev/changelog/compatibility-guide

Compatibility guide for Honcho's SDKs and API

This guide helps you understand which versions of Honcho's API are compatible with which SDK versions.

## Version Compatibility

### Honcho API v2.3.0 (Current)

<CardGroup cols={2}>
  <Card title="TypeScript SDK" icon="js">
    **Compatible Version:** v1.4.0

    Install with:

    ```bash
    npm install @honcho-ai/sdk@1.4.0
    ```
  </Card>

  <Card title="Python SDK" icon="python">
    **Compatible Version:** v1.4.0

    Install with:

    ```bash
    pip install honcho-ai==1.4.0
    ```
  </Card>
</CardGroup>

## Version Compatibility Table

| Honcho API Version | TypeScript SDK | Python SDK |
| ------------------ | -------------- | ---------- |
| v2.3.0 (Current)   | v1.4.0         | v1.4.0     |
| v2.2.0             | v1.3.0         | v1.3.0     |
| v2.1.1             | v1.2.1         | v1.2.2     |
| v2.1.0             | v1.2.1         | v1.2.2     |
| v2.0.5             | v1.1.0         | v1.1.0     |
| v2.0.4             | v1.1.0         | v1.1.0     |


# Changelog
Source: https://docs.honcho.dev/changelog/introduction



Welcome to the Honcho changelog! This section documents all notable changes to the Honcho API and SDKs.

<Accordion title="How to Read This Changelog">
  Each release is documented with:

  * **Added**: New features and capabilities
  * **Changed**: Modifications to existing functionality
  * **Deprecated**: Features that will be removed in future versions
  * **Removed**: Features that have been removed
  * **Fixed**: Bug fixes and corrections
  * **Security**: Security-related improvements

  ## Version Format

  Honcho follows [Semantic Versioning](https://semver.org/):

  * **MAJOR** version for incompatible API changes
  * **MINOR** version for backwards-compatible functionality additions
  * **PATCH** version for backwards-compatible bug fixes
</Accordion>

### Honcho API and SDK Changelogs

<Tabs>
  <Tab title="Honcho API">
    <Update label="v2.3.0 (Current)">
      ### Added

      * `getSummaries` endpoint to get all available summaries for a session directly
      * Peer Card feature to improve context for deriver and dialectic

      ### Changed

      * Session Peer limit to be based on observers instead, renamed config value to
        `SESSION_OBSERVERS_LIMIT`
      * `Messages` can take a custom timestamp for the `created_at` field, defaulting
        to the current time
      * `get_context` endpoint returns detailed `Summary` object rather than just
        summary content
      * Working representations use a FIFO queue structure to maintain facts rather
        than a full rewrite
      * Optimized deriver enqueue by prefetching message sequence numbers (eliminates N+1 queries)

      ### Fixed

      * Deriver uses `get_context` internally to prevent context window limit errors
      * Embedding store will truncate context when querying documents to prevent embedding
        token limit errors
      * Queue manager to schedule work based on available works rather than total
        number of workers
      * Queue manager to use atomic db transactions rather than long lived transaction
        for the worker lifecycle
      * Timestamp formats unified to ISO 8601 across the codebase
      * Internal get\_context method's cutoff value is exclusive now
    </Update>

    <Update label="v2.2.0">
      ### Added

      * Arbitrary filters now available on all search endpoints
      * Search combines full-text and semantic using reciprocal rank fusion
      * Webhook support (currently only supports queue\_empty and test events, more to come)
      * Small test harness and custom test format for evaluating Honcho output quality
      * Added MCP server and documentation for it

      ### Changed

      * Search has 10 results by default, max 100 results
      * Queue structure generalized to handle more event types
      * Summarizer now exhaustive by default and tuned for performance

      ### Fixed

      * Resolve race condition for peers that leave a session while sending messages
      * Added explicit rollback to solve integrity error in queue
      * Re-introduced Sentry tracing to deriver
      * Better integrity logic in get\_or\_create API methods
    </Update>

    <Update label="v2.1.2">
      ### Fixed

      * Summarizer module to ignore empty summaries and pass appropriate one to get\_context
      * Structured Outputs calls with OpenAI provider to pass strict=True to Pydantic Schema
    </Update>

    <Update label="v2.1.1">
      ### Added

      * Test harness for custom Honcho evaluations
      * Better support for session and peer aware dialectic queries
      * Langfuse settings
      * Added recent history to dialectic prompt, dynamic based on new context window size setting

      ### Fixed

      * Summary queue logic
      * Formatting of logs
      * Filtering by session
      * Peer targeting in queries

      ### Changed

      * Made query expansion in dialectic off by default
      * Overhauled logging
      * Refactor summarization for performance and code clarity
      * Refactor queue payloads for clarity
    </Update>

    <Update label="v2.1.0">
      ### Added

      * File uploads
      * Brand new "ROTE" deriver system
      * Updated dialectic system
      * Local working representations
      * Better logging for deriver/dialectic
      * Deriver Queue Status no longer has redundant data

      ### Fixed

      * Document insertion
      * Session-scoped and peer-targeted dialectic queries work now
      * Minor bugs

      ### Removed

      * Peer-level messages

      ### Changed

      * Dialectic chat endpoint takes a single query
      * Rearranged configuration values (LLM, Deriver, Dialectic, History->Summary)
    </Update>

    <Update label="v2.0.5">
      ### Fixed

      * Groq API client to use the Async library
    </Update>

    <Update label="v2.0.4">
      ### Fixed

      * Migration/provision scripts did not have correct database connection arguments, causing timeouts
    </Update>

    <Update label="v2.0.3">
      ### Fixed

      * Bug that causes runtime error when Sentry flags are enabled
    </Update>

    <Update label="v2.0.2">
      ### Fixed

      * Database initialization was misconfigured and led to provision\_db script failing: switch to consistent working configuration with transaction pooler
    </Update>

    <Update label="v2.0.1">
      ### Added

      * Ergonomic SDKs for Python and TypeScript (uses Stainless underneath)
      * Deriver Queue Status endpoint
      * Complex arbitrary filters on workspace/session/peer/message
      * Message embedding table for full semantic search

      ### Changed

      * Overhauled documentation
      * BasedPyright typing for entire project
      * Resource filtering expanded to include logical operators

      ### Fixed

      * Various bugs
      * Use new config arrangement everywhere
      * Remove hardcoded responses
    </Update>

    <Update label="v2.0.0">
      ### Added

      * Ability to get a peer's working representation
      * Metadata to all data primitives (Workspaces, Peers, Sessions, Messages)
      * Internal metadata to store Honcho's state no longer exposed in API
      * Batch message operations and enhanced message querying with token and message count limits
      * Search and summary functionalities scoped by workspace, peer, and session
      * Session context retrieval with summaries and token allocatio
      * HNSW Index for Documents Table
      * Centralized Configuration via Environment Variables or config.toml file

      ### Changed

      * New architecture centered around the concept of a "peer" replaces the former
        "app"/"user"/"session" paradigm
      * Workspaces replace "apps" as top-level namespace
      * Peers replace "users"
      * Sessions no longer nested beneath peers and no longer limited to a single
        user-assistant model. A session exists independently of any one peer and
        peers can be added to and removed from sessions.
      * Dialectic API is now part of the Peer, not the Session
      * Dialectic API now allows queries to be scoped to a session or "targeted"
        to a fellow peer
      * Database schema migrated to adopt workspace/peer/session naming and structure
      * Authentication and JWT scopes updated to workspace/peer/session hierarchy
      * Queue processing now works on 'work units' instead of sessions
      * Message token counting updated with tiktoken integration and fallback heuristic
      * Queue and message processing updated to handle sender/target and task types for multi-peer scenarios

      ### Fixed

      * Improved error handling and validation for batch message operations and metadata
      * Database Sessions to be more atomic to reduce idle in transaction time

      ### Removed

      * Metamessages removed in favor of metadata
      * Collections and Documents no longer exposed in the API, solely internal
      * Obsolete tests for apps, users, collections, documents, and metamessages

      ***
    </Update>

    <Update label="v1.1.0">
      ### Added

      * Normalize resources to remove joins and increase query performance
      * Query tracing for debugging

      ### Changed

      * `/list` endpoints to not require a request body
      * `metamessage_type` to `label` with backwards compatability
      * Database Provisioning to rely on alembic
      * Database Session Manager to explicitly rollback transactions before closing
        the connection

      ### Fixed

      * Alembic Migrations to include initial database migrations
      * Sentry Middleware to not report Honcho Exceptions
    </Update>

    <Update label="v1.0.0">
      ### Added

      * JWT based API authentication
      * Configurable logging
      * Consolidated LLM Inference via `ModelClient` class
      * Dynamic logging configurable via environment variables

      ### Changed

      * Deriver & Dialectic API to use Hybrid Memory Architecture
      * Metamessages are not strictly tied to a message
      * Database provisioning is a separate script instead of happening on startup
      * Consolidated `session/chat` and `session/chat/stream` endpoints
    </Update>

    ## Previous Releases

    For a complete history of all releases, see our [GitHub Releases](https://github.com/plastic-labs/honcho/tags) page.
  </Tab>

  <Tab title="Python SDK">
    [Python SDK](https://pypi.org/project/honcho-ai/)

    <Update label="v1.4.0 (Current)">
      ### Added

      * getSummaries API returning structured summaries
      * Webhook support

      ### Changed

      * Messages can take an optional `created_at` value, defaulting to the current
        time (UTC ISO 8601)
    </Update>

    <Update label="v1.2.2">
      ### Added

      * Filter parameter to various endpoints
    </Update>

    <Update label="v1.2.1">
      ### Fixed

      * Honcho util import paths
    </Update>

    <Update label="v1.2.0">
      ### Added

      * Get/poll deriver queue status endpoints added to workspace
      * Added endpoint to upload files as messages

      ### Removed

      * Removed peer messages in accordance with Honcho 2.1.0

      ### Changed

      * Updated chat endpoint to use singular `query` in accordance with Honcho 2.1.0
    </Update>

    <Update label="v1.1.0">
      ### Fixed

      * Properly handle AsyncClient
    </Update>
  </Tab>

  <Tab title="TypeScript SDK">
    [TypeScript SDK](https://www.npmjs.com/package/@honcho-ai/sdk)

    <Update label="v1.4.0 (Current)">
      ### Added

      * getSummaries API returning structured summaries
      * Webhook support

      ### Changed

      * Messages can take an optional `created_at` value, defaulting to the current
        time (UTC ISO 8601)
    </Update>

    <Update label="v1.2.1">
      ### Added

      * linting via Biome
      * Adding filter parameter to various endpoints

      ### Fixed

      * Order of parameters in `getSessions` endpoint
    </Update>

    <Update label="v1.2.0">
      ### Added

      * Get/poll deriver queue status endpoints added to workspace
      * Added endpoint to upload files as messages

      ### Removed

      * Removed peer messages in accordance with Honcho 2.1.0

      ### Changed

      * Updated chat endpoint to use singular `query` in accordance with Honcho 2.1.0
    </Update>

    <Update label="v1.1.0">
      ### Fixed

      * Create default workspace on Honcho client instantiation
      * Simplified Honcho client import path
    </Update>
  </Tab>
</Tabs>

## Getting Help

If you encounter issues using the Honcho API or its SDKs:

1. Open an issue on [GitHub](https://github.com/plastic-labs/honcho/issues)
2. Join our [Discord community](http://discord.gg/plasticlabs) for support


# Create Key
Source: https://docs.honcho.dev/v2/api-reference/endpoint/keys/create-key

post /v2/keys
Create a new Key



# Create Messages For Session
Source: https://docs.honcho.dev/v2/api-reference/endpoint/messages/create-messages-for-session

post /v2/workspaces/{workspace_id}/sessions/{session_id}/messages/
Create messages for a session with JSON data (original functionality).



# Create Messages With File
Source: https://docs.honcho.dev/v2/api-reference/endpoint/messages/create-messages-with-file

post /v2/workspaces/{workspace_id}/sessions/{session_id}/messages/upload
Create messages from uploaded files. Files are converted to text and split into multiple messages.



# Get Message
Source: https://docs.honcho.dev/v2/api-reference/endpoint/messages/get-message

get /v2/workspaces/{workspace_id}/sessions/{session_id}/messages/{message_id}
Get a Message by ID



# Get Messages
Source: https://docs.honcho.dev/v2/api-reference/endpoint/messages/get-messages

post /v2/workspaces/{workspace_id}/sessions/{session_id}/messages/list
Get all messages for a session



# Update Message
Source: https://docs.honcho.dev/v2/api-reference/endpoint/messages/update-message

put /v2/workspaces/{workspace_id}/sessions/{session_id}/messages/{message_id}
Update the metadata of a Message



# Chat
Source: https://docs.honcho.dev/v2/api-reference/endpoint/peers/chat

post /v2/workspaces/{workspace_id}/peers/{peer_id}/chat



# Get Or Create Peer
Source: https://docs.honcho.dev/v2/api-reference/endpoint/peers/get-or-create-peer

post /v2/workspaces/{workspace_id}/peers
Get a Peer by ID

If peer_id is provided as a query parameter, it uses that (must match JWT workspace_id).
Otherwise, it uses the peer_id from the JWT.



# Get Peers
Source: https://docs.honcho.dev/v2/api-reference/endpoint/peers/get-peers

post /v2/workspaces/{workspace_id}/peers/list
Get All Peers for a Workspace



# Get Sessions For Peer
Source: https://docs.honcho.dev/v2/api-reference/endpoint/peers/get-sessions-for-peer

post /v2/workspaces/{workspace_id}/peers/{peer_id}/sessions
Get All Sessions for a Peer



# Get Working Representation
Source: https://docs.honcho.dev/v2/api-reference/endpoint/peers/get-working-representation

post /v2/workspaces/{workspace_id}/peers/{peer_id}/representation
Get a peer's working representation for a session.

If a session_id is provided in the body, we get the working representation of the peer in that session.
If a target is provided, we get the representation of the target from the perspective of the peer.
If no target is provided, we get the global representation of the peer.



# Search Peer
Source: https://docs.honcho.dev/v2/api-reference/endpoint/peers/search-peer

post /v2/workspaces/{workspace_id}/peers/{peer_id}/search
Search a Peer



# Update Peer
Source: https://docs.honcho.dev/v2/api-reference/endpoint/peers/update-peer

put /v2/workspaces/{workspace_id}/peers/{peer_id}
Update a Peer's name and/or metadata



# Add Peers To Session
Source: https://docs.honcho.dev/v2/api-reference/endpoint/sessions/add-peers-to-session

post /v2/workspaces/{workspace_id}/sessions/{session_id}/peers
Add peers to a session



# Clone Session
Source: https://docs.honcho.dev/v2/api-reference/endpoint/sessions/clone-session

get /v2/workspaces/{workspace_id}/sessions/{session_id}/clone
Clone a session, optionally up to a specific message



# Delete Session
Source: https://docs.honcho.dev/v2/api-reference/endpoint/sessions/delete-session

delete /v2/workspaces/{workspace_id}/sessions/{session_id}
Delete a session by marking it as inactive



# Get Or Create Session
Source: https://docs.honcho.dev/v2/api-reference/endpoint/sessions/get-or-create-session

post /v2/workspaces/{workspace_id}/sessions
Get a specific session in a workspace.

If session_id is provided as a query parameter, it verifies the session is in the workspace.
Otherwise, it uses the session_id from the JWT for verification.



# Get Peer Config
Source: https://docs.honcho.dev/v2/api-reference/endpoint/sessions/get-peer-config

get /v2/workspaces/{workspace_id}/sessions/{session_id}/peers/{peer_id}/config
Get the configuration for a peer in a session



# Get Session Context
Source: https://docs.honcho.dev/v2/api-reference/endpoint/sessions/get-session-context

get /v2/workspaces/{workspace_id}/sessions/{session_id}/context
Produce a context object from the session. The caller provides an optional token limit which the entire context must fit into.
If not provided, the context will be exhaustive (within configured max tokens). To do this, we allocate 40% of the token limit
to the summary, and 60% to recent messages -- as many as can fit. Note that the summary will usually take up less space than
this. If the caller does not want a summary, we allocate all the tokens to recent messages.



# Get Session Peers
Source: https://docs.honcho.dev/v2/api-reference/endpoint/sessions/get-session-peers

get /v2/workspaces/{workspace_id}/sessions/{session_id}/peers
Get peers from a session



# Get Session Summaries
Source: https://docs.honcho.dev/v2/api-reference/endpoint/sessions/get-session-summaries

get /v2/workspaces/{workspace_id}/sessions/{session_id}/summaries
Get available summaries for a session.

Returns both short and long summaries if available, including metadata like
the message ID they cover up to, creation timestamp, and token count.



# Get Sessions
Source: https://docs.honcho.dev/v2/api-reference/endpoint/sessions/get-sessions

post /v2/workspaces/{workspace_id}/sessions/list
Get All Sessions in a Workspace



# Remove Peers From Session
Source: https://docs.honcho.dev/v2/api-reference/endpoint/sessions/remove-peers-from-session

delete /v2/workspaces/{workspace_id}/sessions/{session_id}/peers
Remove peers from a session



# Search Session
Source: https://docs.honcho.dev/v2/api-reference/endpoint/sessions/search-session

post /v2/workspaces/{workspace_id}/sessions/{session_id}/search
Search a Session



# Set Peer Config
Source: https://docs.honcho.dev/v2/api-reference/endpoint/sessions/set-peer-config

post /v2/workspaces/{workspace_id}/sessions/{session_id}/peers/{peer_id}/config
Set the configuration for a peer in a session



# Set Session Peers
Source: https://docs.honcho.dev/v2/api-reference/endpoint/sessions/set-session-peers

put /v2/workspaces/{workspace_id}/sessions/{session_id}/peers
Set the peers in a session



# Update Session
Source: https://docs.honcho.dev/v2/api-reference/endpoint/sessions/update-session

put /v2/workspaces/{workspace_id}/sessions/{session_id}
Update the metadata of a Session



# Delete Webhook Endpoint
Source: https://docs.honcho.dev/v2/api-reference/endpoint/webhooks/delete-webhook-endpoint

delete /v2/workspaces/{workspace_id}/webhooks/{endpoint_id}
Delete a specific webhook endpoint.



# Get Or Create Webhook Endpoint
Source: https://docs.honcho.dev/v2/api-reference/endpoint/webhooks/get-or-create-webhook-endpoint

post /v2/workspaces/{workspace_id}/webhooks
Get or create a webhook endpoint URL.



# List Webhook Endpoints
Source: https://docs.honcho.dev/v2/api-reference/endpoint/webhooks/list-webhook-endpoints

get /v2/workspaces/{workspace_id}/webhooks
List all webhook endpoints, optionally filtered by workspace.



# Test Emit
Source: https://docs.honcho.dev/v2/api-reference/endpoint/webhooks/test-emit

get /v2/workspaces/{workspace_id}/webhooks/test
Test publishing a webhook event.



# Get All Workspaces
Source: https://docs.honcho.dev/v2/api-reference/endpoint/workspaces/get-all-workspaces

post /v2/workspaces/list
Get all Workspaces



# Get Deriver Status
Source: https://docs.honcho.dev/v2/api-reference/endpoint/workspaces/get-deriver-status

get /v2/workspaces/{workspace_id}/deriver/status
Get the deriver processing status, optionally scoped to an observer, sender, and/or session



# Get Or Create Workspace
Source: https://docs.honcho.dev/v2/api-reference/endpoint/workspaces/get-or-create-workspace

post /v2/workspaces
Get a Workspace by ID.

If workspace_id is provided as a query parameter, it uses that (must match JWT workspace_id).
Otherwise, it uses the workspace_id from the JWT.



# Search Workspace
Source: https://docs.honcho.dev/v2/api-reference/endpoint/workspaces/search-workspace

post /v2/workspaces/{workspace_id}/search
Search a Workspace



# Update Workspace
Source: https://docs.honcho.dev/v2/api-reference/endpoint/workspaces/update-workspace

put /v2/workspaces/{workspace_id}
Update a Workspace



# Introduction
Source: https://docs.honcho.dev/v2/api-reference/introduction



This section documents all available API endpoints in the Honcho Server. Each
endpoint provides CRUD operations for our core primitives. For information
about these primitives, see
[Architecture](/v2/documentation/core-concepts/architecture).

<Warning>
  We strongly recommend using our official SDKs instead of calling these APIs directly. The SDKs provide better error handling, type safety, and developer experience.
</Warning>

## Recommended approach

Use our official SDKs for the best development experience:

* [Python SDK](https://pypi.org/project/honcho-ai/)
* [TypeScript SDK](https://www.npmjs.com/package/@honcho-ai/sdk)

## When to use this API reference

This reference is primarily useful for:

* Debugging SDK behavior
* Building integrations in unsupported languages
* Understanding the underlying data structures

The endpoints pages are autogenerated and include interactive examples for testing.


# Configuration Guide
Source: https://docs.honcho.dev/v2/contributing/configuration

Complete guide to configuring Honcho for development and production

Honcho uses a flexible configuration system that supports both TOML files and environment variables. Configuration values are loaded in the following priority order (highest to lowest):

1. Environment variables (always take precedence)
2. `.env` file (for local development)
3. `config.toml` file (base configuration)
4. Default values

## Recommended Configuration Approaches

### Option 1: Environment Variables Only (Production)

* Use environment variables for all configuration
* No config files needed
* Ideal for containerized deployments (Docker, Kubernetes)
* Secrets managed by your deployment platform

### Option 2: config.toml (Development/Simple Deployments)

* Use config.toml for base configuration
* Override sensitive values with environment variables
* Good for development and simple deployments

### Option 3: Hybrid Approach

* Use config.toml for non-sensitive base settings
* Use .env file for sensitive values (API keys, secrets)
* Good for development teams

### Option 4: .env Only (Local Development)

* Use .env file for all configuration
* Simple for local development
* Never commit .env files to version control

## Configuration Methods

### Using config.toml

Copy the example configuration file to get started:

```bash
cp config.toml.example config.toml
```

Then modify the values as needed. The TOML file is organized into sections:

* `[app]` - Application-level settings (log level, host, port, embedding settings)
* `[db]` - Database connection and pool settings
* `[auth]` - Authentication configuration
* `[llm]` - LLM provider API keys and general settings
* `[dialectic]` - Dialectic API configuration (provider, model, search settings)
* `[deriver]` - Background worker settings and theory of mind configuration
* `[summary]` - Session summarization settings
* `[sentry]` - Error tracking and monitoring settings

### Using Environment Variables

All configuration values can be overridden using environment variables. The environment variable names follow this pattern:

* `{SECTION}_{KEY}` for nested settings
* Just `{KEY}` for app-level settings

Examples:

* `DB_CONNECTION_URI` → `[db].CONNECTION_URI`
* `DB_POOL_SIZE`      → `[db].POOL_SIZE`
* `AUTH_JWT_SECRET`   → `[auth].JWT_SECRET`
* `DIALECTIC_MODEL` → `[dialectic].MODEL`
* `LOG_LEVEL` (no section) → `[app].LOG_LEVEL`

### Configuration Priority

When a configuration value is set in multiple places, Honcho uses this priority:

1. **Environment variables** - Always take precedence
2. **.env file** - Loaded for local development
3. **config.toml** - Base configuration
4. **Default values** - Built-in defaults

This allows you to:

* Use `config.toml` for base configuration
* Override specific values with environment variables in production
* Use `.env` files for local development without modifying config.toml

### Example

If you have this in `config.toml`:

```toml
[db]
CONNECTION_URI = "postgresql://localhost/honcho_dev"
POOL_SIZE = 10
```

You can override just the connection URI in production:

```bash
export DB_CONNECTION_URI="postgresql://prod-server/honcho_prod"
```

The application will use the production connection URI while keeping the pool size from config.toml.

## Core Configuration

### Application Settings

**Basic Application Configuration:**

```bash
# Logging and server settings
LOG_LEVEL=INFO  # DEBUG, INFO, WARNING, ERROR
SESSION_PEERS_LIMIT=10
GET_CONTEXT_MAX_TOKENS=100000

# Embedding settings (optional)
EMBED_MESSAGES=false
MAX_EMBEDDING_TOKENS=8192
MAX_EMBEDDING_TOKENS_PER_REQUEST=300000
```

**Environment-specific settings:**

```bash
# Development
LOG_LEVEL=DEBUG
FASTAPI_HOST=127.0.0.1

# Production
LOG_LEVEL=WARNING
FASTAPI_HOST=0.0.0.0
```

### Database Configuration

**Required Database Settings:**

```bash
# PostgreSQL connection string (required)
DB_CONNECTION_URI=postgresql+psycopg://username:password@host:port/database

# Example for local development
DB_CONNECTION_URI=postgresql+psycopg://postgres:postgres@localhost:5432/honcho

# Example for production
DB_CONNECTION_URI=postgresql+psycopg://honcho_user:secure_password@db.example.com:5432/honcho_prod
```

**Database Pool Settings:**

```bash
# Connection pool configuration
DB_SCHEMA=public
DB_POOL_SIZE=10
DB_MAX_OVERFLOW=20
DB_POOL_TIMEOUT=30
DB_POOL_RECYCLE=300
DB_POOL_PRE_PING=true
DB_SQL_DEBUG=false
DB_TRACING=false
```

**Docker Compose for PostgreSQL:**

```yaml
# docker-compose.yml
version: '3.8'
services:
  database:
    image: pgvector/pgvector:pg15
    environment:
      POSTGRES_USER: postgres
      POSTGRES_PASSWORD: postgres
      POSTGRES_DB: honcho
    ports:
      - "5432:5432"
    volumes:
      - postgres_data:/var/lib/postgresql/data
      - ./init.sql:/docker-entrypoint-initdb.d/init.sql

volumes:
  postgres_data:
```

### Authentication Configuration

**JWT Authentication:**

```bash
# Enable/disable authentication
AUTH_USE_AUTH=false  # Set to true for production

# JWT settings (required if AUTH_USE_AUTH is true)
AUTH_JWT_SECRET=your-super-secret-jwt-key
```

**Generate JWT Secret:**

```bash
# Generate a secure JWT secret
python scripts/generate_jwt_secret.py
```

## LLM Provider Configuration

Honcho supports multiple LLM providers for different tasks. API keys are configured in the `[llm]` section, while specific features use their own configuration sections.

### API Keys

All provider API keys use the `LLM_` prefix:

```bash
# Provider API Keys
LLM_ANTHROPIC_API_KEY=your-anthropic-api-key
LLM_OPENAI_API_KEY=your-openai-api-key
LLM_GEMINI_API_KEY=your-gemini-api-key
LLM_GROQ_API_KEY=your-groq-api-key

# OpenAI-compatible endpoints
LLM_OPENAI_COMPATIBLE_API_KEY=your-api-key
LLM_OPENAI_COMPATIBLE_BASE_URL=https://your-openai-compatible-endpoint.com
```

### General LLM Settings

```bash
# Default settings for all LLM calls
LLM_DEFAULT_MAX_TOKENS=2500
```

### Feature-Specific Model Configuration

Different features can use different providers and models:

**Dialectic API:**

```bash
# Main dialectic model (default: Anthropic)
DIALECTIC_PROVIDER=anthropic
DIALECTIC_MODEL=claude-sonnet-4-20250514
DIALECTIC_MAX_OUTPUT_TOKENS=2500
DIALECTIC_THINKING_BUDGET_TOKENS=1024

# Query generation for dialectic (default: Groq)
DIALECTIC_QUERY_GENERATION_PROVIDER=groq
DIALECTIC_QUERY_GENERATION_MODEL=llama-3.1-8b-instant

# Semantic search settings
DIALECTIC_SEMANTIC_SEARCH_TOP_K=10
DIALECTIC_SEMANTIC_SEARCH_MAX_DISTANCE=0.85
```

**Deriver:**

```bash
# Deriver model (default: Google)
DERIVER_PROVIDER=google
DERIVER_MODEL=gemini-2.0-flash-lite

# Worker settings
DERIVER_WORKERS=1
DERIVER_STALE_SESSION_TIMEOUT_MINUTES=5
DERIVER_POLLING_SLEEP_INTERVAL_SECONDS=1.0

# Peer card settings
DERIVER_PEER_CARD_PROVIDER=openai
DERIVER_PEER_CARD_MODEL=gpt-5-nano-2025-08-07
DERIVER_PEER_CARD_MAX_OUTPUT_TOKENS=2000

# Context token limit for get_context method
DERIVER_CONTEXT_TOKEN_LIMIT=30000

# Maximum number of observations to store in working representation
# This is applied to both explicit and deductive observations
DERIVER_WORKING_REPRESENTATION_MAX_OBSERVATIONS=100
```

**Summary Generation:**

```bash
# Summary model (default: Google)
SUMMARY_PROVIDER=google
SUMMARY_MODEL=gemini-1.5-flash-latest
SUMMARY_MAX_TOKENS_SHORT=1000
SUMMARY_MAX_TOKENS_LONG=2000
SUMMARY_THINKING_BUDGET_TOKENS=512

# Summary frequency
SUMMARY_MESSAGES_PER_SHORT_SUMMARY=20
SUMMARY_MESSAGES_PER_LONG_SUMMARY=60
```

### Default Provider Usage

By default, Honcho uses:

* **Anthropic** for dialectic API responses
* **Groq** for query generation
* **Google** for deriving theory of mind and summarization
* **OpenAI** for embeddings (if `EMBED_MESSAGES=true`)

You only need to set the API keys for the providers you plan to use.

## Monitoring Configuration

### Sentry Error Tracking

**Sentry Settings:**

```bash
# Enable/disable Sentry
SENTRY_ENABLED=false

# Sentry configuration
SENTRY_DSN=https://your-sentry-dsn@sentry.io/project-id
SENTRY_TRACES_SAMPLE_RATE=0.1
SENTRY_PROFILES_SAMPLE_RATE=0.1
```

## Environment-Specific Examples

### Development Configuration

**config.toml for development:**

```toml
[app]
LOG_LEVEL = "DEBUG"
SESSION_PEERS_LIMIT = 10
EMBED_MESSAGES = false

[db]
CONNECTION_URI = "postgresql+psycopg://postgres:postgres@localhost:5432/honcho_dev"
POOL_SIZE = 5

[auth]
USE_AUTH = false

[dialectic]
PROVIDER = "anthropic"
MODEL = "claude-sonnet-4-20250514"
QUERY_GENERATION_PROVIDER = "groq"
QUERY_GENERATION_MODEL = "llama-3.1-8b-instant"
MAX_OUTPUT_TOKENS = 2500

[summary]
PROVIDER = "google"
MODEL = "gemini-1.5-flash-latest"
MAX_TOKENS_SHORT = 1000
MAX_TOKENS_LONG = 2000

[deriver]
WORKERS = 1

[sentry]
ENABLED = false
```

**Environment variables for development:**

```bash
# .env.development
LOG_LEVEL=DEBUG
DB_CONNECTION_URI=postgresql+psycopg://postgres:postgres@localhost:5432/honcho_dev
AUTH_USE_AUTH=false
ANTHROPIC_API_KEY=your-dev-anthropic-key
```

### Production Configuration

**config.toml for production:**

```toml
[app]
LOG_LEVEL = "WARNING"
SESSION_PEERS_LIMIT = 10
EMBED_MESSAGES = true

[db]
CONNECTION_URI = "postgresql+psycopg://honcho_user:secure_password@prod-db:5432/honcho_prod"
POOL_SIZE = 20
MAX_OVERFLOW = 40

[auth]
USE_AUTH = true

[dialectic]
PROVIDER = "anthropic"
MODEL = "claude-sonnet-4-20250514"
QUERY_GENERATION_PROVIDER = "groq"
QUERY_GENERATION_MODEL = "llama-3.1-8b-instant"
MAX_OUTPUT_TOKENS = 2500

[summary]
PROVIDER = "google"
MODEL = "gemini-1.5-flash-latest"
MAX_TOKENS_SHORT = 1000
MAX_TOKENS_LONG = 2000

[deriver]
WORKERS = 4
PROVIDER = "google"
MODEL = "gemini-2.0-flash-lite"

[sentry]
ENABLED = true
TRACES_SAMPLE_RATE = 0.1
```

**Environment variables for production:**

```bash
# .env.production
LOG_LEVEL=WARNING
DB_CONNECTION_URI=postgresql+psycopg://honcho_user:secure_password@prod-db:5432/honcho_prod
AUTH_USE_AUTH=true
AUTH_JWT_SECRET=your-super-secret-jwt-key
ANTHROPIC_API_KEY=your-prod-anthropic-key
GEMINI_API_KEY=your-prod-gemini-key
SENTRY_DSN=https://your-sentry-dsn@sentry.io/project-id
```

## Migration Management

**Running Database Migrations:**

```bash
# Check current migration status
uv run alembic current

# Upgrade to latest
uv run alembic upgrade head

# Downgrade to specific revision
uv run alembic downgrade revision_id

# Create new migration
uv run alembic revision --autogenerate -m "Description of changes"
```

## Troubleshooting

**Common Configuration Issues:**

1. **Database Connection Errors**
   * Ensure `DB_CONNECTION_URI` uses `postgresql+psycopg://` prefix
   * Verify database is running and accessible
   * Check pgvector extension is installed

2. **Authentication Issues**
   * Set `AUTH_USE_AUTH=true` for production
   * Generate and set `AUTH_JWT_SECRET` if authentication is enabled
   * Use `python scripts/generate_jwt_secret.py` to create a secure secret

3. **LLM Provider Issues**
   * Verify API keys are set correctly
   * Check model names match provider specifications
   * Ensure provider is enabled in configuration

4. **Deriver Issues**
   * Increase `DERIVER_WORKERS` for better performance
   * Check `DERIVER_STALE_SESSION_TIMEOUT_MINUTES` for session cleanup
   * Monitor background processing logs

This configuration guide covers all the settings available in Honcho. Always use environment-specific configuration files and never commit sensitive values like API keys or JWT secrets to version control.


# Contributing Guidelines
Source: https://docs.honcho.dev/v2/contributing/guidelines



Thank you for your interest in contributing to Honcho! This guide outlines the process for contributing to the project and our development conventions.

## Getting Started

Before you start contributing, please:

1. **Set up your development environment** - Follow the [Local Development guide](https://github.com/plastic-labs/honcho/blob/main/CONTRIBUTING.md#local-development) in the Honcho repository to get Honcho running locally.

2. **Join our community** - Feel free to join us in our [Discord](http://discord.gg/plasticlabs) to discuss your changes, get help, or ask questions.

3. **Review existing issues** - Check the [issues tab](https://github.com/plastic-labs/honcho/issues) to see what's already being worked on or to find something to contribute to.

## Contribution Workflow

### 1. Fork and Clone

1. Fork the repository on GitHub
2. Clone your fork locally:
   ```bash
   git clone https://github.com/YOUR_USERNAME/honcho.git
   cd honcho
   ```
3. Add the upstream repository as a remote:
   ```bash
   git remote add upstream https://github.com/plastic-labs/honcho.git
   ```

### 2. Create a Branch

Create a new branch for your feature or bug fix:

```bash
git checkout -b feature/your-feature-name
# or
git checkout -b fix/your-bug-fix-name
```

**Branch naming conventions:**

* `feature/description` - for new features
* `fix/description` - for bug fixes
* `docs/description` - for documentation updates
* `refactor/description` - for code refactoring
* `test/description` - for adding or updating tests

### 3. Make Your Changes

* Write clean, readable code that follows our coding standards (see below)
* Add tests for new functionality
* Update documentation as needed
* Make sure your changes don't break existing functionality

### 4. Commit Your Changes

We follow conventional commit standards. Format your commit messages as:

```
type(scope): description

[optional body]

[optional footer]
```

**Types:**

* `feat`: A new feature
* `fix`: A bug fix
* `docs`: Documentation only changes
* `style`: Changes that do not affect the meaning of the code
* `refactor`: A code change that neither fixes a bug nor adds a feature
* `test`: Adding missing tests or correcting existing tests
* `chore`: Changes to the build process or auxiliary tools

**Examples:**

```bash
git commit -m "feat(api): add new dialectic endpoint for user insights"
git commit -m "fix(db): resolve connection pool timeout issue"
git commit -m "docs(readme): update installation instructions"
```

### 5. Submit a Pull Request

1. Push your branch to your fork:
   ```bash
   git push origin your-branch-name
   ```

2. Create a pull request on GitHub from your branch to the `main` branch

3. Fill out the pull request template with:
   * A clear description of what changes you've made
   * The motivation for the changes
   * Any relevant issue numbers (use "Closes #123" to auto-close issues)
   * Screenshots or examples if applicable

## Coding Standards

### Python Code Style

* Follow [PEP 8](https://www.python.org/dev/peps/pep-0008/) style guidelines
* Use [Black](https://black.readthedocs.io/) for code formatting (we may add this to CI in the future)
* Use type hints where possible
* Write docstrings for functions and classes using Google style docstrings

### Code Organization

* Keep functions focused and single-purpose
* Use meaningful variable and function names
* Add comments for complex logic
* Follow existing patterns in the codebase

### Testing

* Write unit tests for new functionality
* Ensure existing tests pass before submitting
* Use descriptive test names that explain what is being tested
* Mock external dependencies appropriately

### Documentation

* Update relevant documentation for new features
* Include examples in docstrings where helpful
* Keep README and other docs up to date with changes

## Review Process

1. **Automated checks** - Your PR will run through automated checks including tests and linting
2. **Project maintainer review** - A project maintainer will review your code for:
   * Code quality and adherence to standards
   * Functionality and correctness
   * Test coverage
   * Documentation completeness
3. **Discussion and iteration** - You may be asked to make changes or clarifications
4. **Approval and merge** - Once approved, your PR will be merged into `main`

## Types of Contributions

We welcome various types of contributions:

* **Bug fixes** - Help us squash bugs and improve stability
* **New features** - Add functionality that benefits the community
* **Documentation** - Improve or expand our documentation
* **Tests** - Increase test coverage and reliability
* **Performance improvements** - Help make Honcho faster and more efficient
* **Examples and tutorials** - Help other developers use Honcho

## Issue Reporting

When reporting bugs or requesting features:

1. Check if the issue already exists
2. Use the appropriate issue template
3. Provide clear reproduction steps for bugs
4. Include relevant environment information
5. Be specific about expected vs actual behavior

## Questions and Support

* **General questions** - Join our [Discord](http://discord.gg/plasticlabs)
* **Bug reports** - Use GitHub issues
* **Feature requests** - Use GitHub issues with the feature request template
* **Security issues** - Please email us privately rather than opening a public issue

## License

By contributing to Honcho, you agree that your contributions will be licensed under the same [AGPL-3.0 License](./license) that covers the project.

Thank you for helping make Honcho better! 🫡


# License
Source: https://docs.honcho.dev/v2/contributing/license



Honcho is licensed under the AGPL-3.0 License. This is copied below for convenience and also present in the
[GitHub Repository](https://github.com/plastic-labs/honcho)

```
                    GNU AFFERO GENERAL PUBLIC LICENSE
                       Version 3, 19 November 2007

 Copyright (C) 2007 Free Software Foundation, Inc. <https://fsf.org/>
 Everyone is permitted to copy and distribute verbatim copies
 of this license document, but changing it is not allowed.

                            Preamble

  The GNU Affero General Public License is a free, copyleft license for
software and other kinds of works, specifically designed to ensure
cooperation with the community in the case of network server software.

  The licenses for most software and other practical works are designed
to take away your freedom to share and change the works.  By contrast,
our General Public Licenses are intended to guarantee your freedom to
share and change all versions of a program--to make sure it remains free
software for all its users.

  When we speak of free software, we are referring to freedom, not
price.  Our General Public Licenses are designed to make sure that you
have the freedom to distribute copies of free software (and charge for
them if you wish), that you receive source code or can get it if you
want it, that you can change the software or use pieces of it in new
free programs, and that you know you can do these things.

  Developers that use our General Public Licenses protect your rights
with two steps: (1) assert copyright on the software, and (2) offer
you this License which gives you legal permission to copy, distribute
and/or modify the software.

  A secondary benefit of defending all users' freedom is that
improvements made in alternate versions of the program, if they
receive widespread use, become available for other developers to
incorporate.  Many developers of free software are heartened and
encouraged by the resulting cooperation.  However, in the case of
software used on network servers, this result may fail to come about.
The GNU General Public License permits making a modified version and
letting the public access it on a server without ever releasing its
source code to the public.

  The GNU Affero General Public License is designed specifically to
ensure that, in such cases, the modified source code becomes available
to the community.  It requires the operator of a network server to
provide the source code of the modified version running there to the
users of that server.  Therefore, public use of a modified version, on
a publicly accessible server, gives the public access to the source
code of the modified version.

  An older license, called the Affero General Public License and
published by Affero, was designed to accomplish similar goals.  This is
a different license, not a version of the Affero GPL, but Affero has
released a new version of the Affero GPL which permits relicensing under
this license.

  The precise terms and conditions for copying, distribution and
modification follow.

                       TERMS AND CONDITIONS

  0. Definitions.

  "This License" refers to version 3 of the GNU Affero General Public License.

  "Copyright" also means copyright-like laws that apply to other kinds of
works, such as semiconductor masks.

  "The Program" refers to any copyrightable work licensed under this
License.  Each licensee is addressed as "you".  "Licensees" and
"recipients" may be individuals or organizations.

  To "modify" a work means to copy from or adapt all or part of the work
in a fashion requiring copyright permission, other than the making of an
exact copy.  The resulting work is called a "modified version" of the
earlier work or a work "based on" the earlier work.

  A "covered work" means either the unmodified Program or a work based
on the Program.

  To "propagate" a work means to do anything with it that, without
permission, would make you directly or secondarily liable for
infringement under applicable copyright law, except executing it on a
computer or modifying a private copy.  Propagation includes copying,
distribution (with or without modification), making available to the
public, and in some countries other activities as well.

  To "convey" a work means any kind of propagation that enables other
parties to make or receive copies.  Mere interaction with a user through
a computer network, with no transfer of a copy, is not conveying.

  An interactive user interface displays "Appropriate Legal Notices"
to the extent that it includes a convenient and prominently visible
feature that (1) displays an appropriate copyright notice, and (2)
tells the user that there is no warranty for the work (except to the
extent that warranties are provided), that licensees may convey the
work under this License, and how to view a copy of this License.  If
the interface presents a list of user commands or options, such as a
menu, a prominent item in the list meets this criterion.

  1. Source Code.

  The "source code" for a work means the preferred form of the work
for making modifications to it.  "Object code" means any non-source
form of a work.

  A "Standard Interface" means an interface that either is an official
standard defined by a recognized standards body, or, in the case of
interfaces specified for a particular programming language, one that
is widely used among developers working in that language.

  The "System Libraries" of an executable work include anything, other
than the work as a whole, that (a) is included in the normal form of
packaging a Major Component, but which is not part of that Major
Component, and (b) serves only to enable use of the work with that
Major Component, or to implement a Standard Interface for which an
implementation is available to the public in source code form.  A
"Major Component", in this context, means a major essential component
(kernel, window system, and so on) of the specific operating system
(if any) on which the executable work runs, or a compiler used to
produce the work, or an object code interpreter used to run it.

  The "Corresponding Source" for a work in object code form means all
the source code needed to generate, install, and (for an executable
work) run the object code and to modify the work, including scripts to
control those activities.  However, it does not include the work's
System Libraries, or general-purpose tools or generally available free
programs which are used unmodified in performing those activities but
which are not part of the work.  For example, Corresponding Source
includes interface definition files associated with source files for
the work, and the source code for shared libraries and dynamically
linked subprograms that the work is specifically designed to require,
such as by intimate data communication or control flow between those
subprograms and other parts of the work.

  The Corresponding Source need not include anything that users
can regenerate automatically from other parts of the Corresponding
Source.

  The Corresponding Source for a work in source code form is that
same work.

  2. Basic Permissions.

  All rights granted under this License are granted for the term of
copyright on the Program, and are irrevocable provided the stated
conditions are met.  This License explicitly affirms your unlimited
permission to run the unmodified Program.  The output from running a
covered work is covered by this License only if the output, given its
content, constitutes a covered work.  This License acknowledges your
rights of fair use or other equivalent, as provided by copyright law.

  You may make, run and propagate covered works that you do not
convey, without conditions so long as your license otherwise remains
in force.  You may convey covered works to others for the sole purpose
of having them make modifications exclusively for you, or provide you
with facilities for running those works, provided that you comply with
the terms of this License in conveying all material for which you do
not control copyright.  Those thus making or running the covered works
for you must do so exclusively on your behalf, under your direction
and control, on terms that prohibit them from making any copies of
your copyrighted material outside their relationship with you.

  Conveying under any other circumstances is permitted solely under
the conditions stated below.  Sublicensing is not allowed; section 10
makes it unnecessary.

  3. Protecting Users' Legal Rights From Anti-Circumvention Law.

  No covered work shall be deemed part of an effective technological
measure under any applicable law fulfilling obligations under article
11 of the WIPO copyright treaty adopted on 20 December 1996, or
similar laws prohibiting or restricting circumvention of such
measures.

  When you convey a covered work, you waive any legal power to forbid
circumvention of technological measures to the extent such circumvention
is effected by exercising rights under this License with respect to
the covered work, and you disclaim any intention to limit operation or
modification of the work as a means of enforcing, against the work's
users, your or third parties' legal rights to forbid circumvention of
technological measures.

  4. Conveying Verbatim Copies.

  You may convey verbatim copies of the Program's source code as you
receive it, in any medium, provided that you conspicuously and
appropriately publish on each copy an appropriate copyright notice;
keep intact all notices stating that this License and any
non-permissive terms added in accord with section 7 apply to the code;
keep intact all notices of the absence of any warranty; and give all
recipients a copy of this License along with the Program.

  You may charge any price or no price for each copy that you convey,
and you may offer support or warranty protection for a fee.

  5. Conveying Modified Source Versions.

  You may convey a work based on the Program, or the modifications to
produce it from the Program, in the form of source code under the
terms of section 4, provided that you also meet all of these conditions:

    a) The work must carry prominent notices stating that you modified
    it, and giving a relevant date.

    b) The work must carry prominent notices stating that it is
    released under this License and any conditions added under section
    7.  This requirement modifies the requirement in section 4 to
    "keep intact all notices".

    c) You must license the entire work, as a whole, under this
    License to anyone who comes into possession of a copy.  This
    License will therefore apply, along with any applicable section 7
    additional terms, to the whole of the work, and all its parts,
    regardless of how they are packaged.  This License gives no
    permission to license the work in any other way, but it does not
    invalidate such permission if you have separately received it.

    d) If the work has interactive user interfaces, each must display
    Appropriate Legal Notices; however, if the Program has interactive
    interfaces that do not display Appropriate Legal Notices, your
    work need not make them do so.

  A compilation of a covered work with other separate and independent
works, which are not by their nature extensions of the covered work,
and which are not combined with it such as to form a larger program,
in or on a volume of a storage or distribution medium, is called an
"aggregate" if the compilation and its resulting copyright are not
used to limit the access or legal rights of the compilation's users
beyond what the individual works permit.  Inclusion of a covered work
in an aggregate does not cause this License to apply to the other
parts of the aggregate.

  6. Conveying Non-Source Forms.

  You may convey a covered work in object code form under the terms
of sections 4 and 5, provided that you also convey the
machine-readable Corresponding Source under the terms of this License,
in one of these ways:

    a) Convey the object code in, or embodied in, a physical product
    (including a physical distribution medium), accompanied by the
    Corresponding Source fixed on a durable physical medium
    customarily used for software interchange.

    b) Convey the object code in, or embodied in, a physical product
    (including a physical distribution medium), accompanied by a
    written offer, valid for at least three years and valid for as
    long as you offer spare parts or customer support for that product
    model, to give anyone who possesses the object code either (1) a
    copy of the Corresponding Source for all the software in the
    product that is covered by this License, on a durable physical
    medium customarily used for software interchange, for a price no
    more than your reasonable cost of physically performing this
    conveying of source, or (2) access to copy the
    Corresponding Source from a network server at no charge.

    c) Convey individual copies of the object code with a copy of the
    written offer to provide the Corresponding Source.  This
    alternative is allowed only occasionally and noncommercially, and
    only if you received the object code with such an offer, in accord
    with subsection 6b.

    d) Convey the object code by offering access from a designated
    place (gratis or for a charge), and offer equivalent access to the
    Corresponding Source in the same way through the same place at no
    further charge.  You need not require recipients to copy the
    Corresponding Source along with the object code.  If the place to
    copy the object code is a network server, the Corresponding Source
    may be on a different server (operated by you or a third party)
    that supports equivalent copying facilities, provided you maintain
    clear directions next to the object code saying where to find the
    Corresponding Source.  Regardless of what server hosts the
    Corresponding Source, you remain obligated to ensure that it is
    available for as long as needed to satisfy these requirements.

    e) Convey the object code using peer-to-peer transmission, provided
    you inform other peers where the object code and Corresponding
    Source of the work are being offered to the general public at no
    charge under subsection 6d.

  A separable portion of the object code, whose source code is excluded
from the Corresponding Source as a System Library, need not be
included in conveying the object code work.

  A "User Product" is either (1) a "consumer product", which means any
tangible personal property which is normally used for personal, family,
or household purposes, or (2) anything designed or sold for incorporation
into a dwelling.  In determining whether a product is a consumer product,
doubtful cases shall be resolved in favor of coverage.  For a particular
product received by a particular user, "normally used" refers to a
typical or common use of that class of product, regardless of the status
of the particular user or of the way in which the particular user
actually uses, or expects or is expected to use, the product.  A product
is a consumer product regardless of whether the product has substantial
commercial, industrial or non-consumer uses, unless such uses represent
the only significant mode of use of the product.

  "Installation Information" for a User Product means any methods,
procedures, authorization keys, or other information required to install
and execute modified versions of a covered work in that User Product from
a modified version of its Corresponding Source.  The information must
suffice to ensure that the continued functioning of the modified object
code is in no case prevented or interfered with solely because
modification has been made.

  If you convey an object code work under this section in, or with, or
specifically for use in, a User Product, and the conveying occurs as
part of a transaction in which the right of possession and use of the
User Product is transferred to the recipient in perpetuity or for a
fixed term (regardless of how the transaction is characterized), the
Corresponding Source conveyed under this section must be accompanied
by the Installation Information.  But this requirement does not apply
if neither you nor any third party retains the ability to install
modified object code on the User Product (for example, the work has
been installed in ROM).

  The requirement to provide Installation Information does not include a
requirement to continue to provide support service, warranty, or updates
for a work that has been modified or installed by the recipient, or for
the User Product in which it has been modified or installed.  Access to a
network may be denied when the modification itself materially and
adversely affects the operation of the network or violates the rules and
protocols for communication across the network.

  Corresponding Source conveyed, and Installation Information provided,
in accord with this section must be in a format that is publicly
documented (and with an implementation available to the public in
source code form), and must require no special password or key for
unpacking, reading or copying.

  7. Additional Terms.

  "Additional permissions" are terms that supplement the terms of this
License by making exceptions from one or more of its conditions.
Additional permissions that are applicable to the entire Program shall
be treated as though they were included in this License, to the extent
that they are valid under applicable law.  If additional permissions
apply only to part of the Program, that part may be used separately
under those permissions, but the entire Program remains governed by
this License without regard to the additional permissions.

  When you convey a copy of a covered work, you may at your option
remove any additional permissions from that copy, or from any part of
it.  (Additional permissions may be written to require their own
removal in certain cases when you modify the work.)  You may place
additional permissions on material, added by you to a covered work,
for which you have or can give appropriate copyright permission.

  Notwithstanding any other provision of this License, for material you
add to a covered work, you may (if authorized by the copyright holders of
that material) supplement the terms of this License with terms:

    a) Disclaiming warranty or limiting liability differently from the
    terms of sections 15 and 16 of this License; or

    b) Requiring preservation of specified reasonable legal notices or
    author attributions in that material or in the Appropriate Legal
    Notices displayed by works containing it; or

    c) Prohibiting misrepresentation of the origin of that material, or
    requiring that modified versions of such material be marked in
    reasonable ways as different from the original version; or

    d) Limiting the use for publicity purposes of names of licensors or
    authors of the material; or

    e) Declining to grant rights under trademark law for use of some
    trade names, trademarks, or service marks; or

    f) Requiring indemnification of licensors and authors of that
    material by anyone who conveys the material (or modified versions of
    it) with contractual assumptions of liability to the recipient, for
    any liability that these contractual assumptions directly impose on
    those licensors and authors.

  All other non-permissive additional terms are considered "further
restrictions" within the meaning of section 10.  If the Program as you
received it, or any part of it, contains a notice stating that it is
governed by this License along with a term that is a further
restriction, you may remove that term.  If a license document contains
a further restriction but permits relicensing or conveying under this
License, you may add to a covered work material governed by the terms
of that license document, provided that the further restriction does
not survive such relicensing or conveying.

  If you add terms to a covered work in accord with this section, you
must place, in the relevant source files, a statement of the
additional terms that apply to those files, or a notice indicating
where to find the applicable terms.

  Additional terms, permissive or non-permissive, may be stated in the
form of a separately written license, or stated as exceptions;
the above requirements apply either way.

  8. Termination.

  You may not propagate or modify a covered work except as expressly
provided under this License.  Any attempt otherwise to propagate or
modify it is void, and will automatically terminate your rights under
this License (including any patent licenses granted under the third
paragraph of section 11).

  However, if you cease all violation of this License, then your
license from a particular copyright holder is reinstated (a)
provisionally, unless and until the copyright holder explicitly and
finally terminates your license, and (b) permanently, if the copyright
holder fails to notify you of the violation by some reasonable means
prior to 60 days after the cessation.

  Moreover, your license from a particular copyright holder is
reinstated permanently if the copyright holder notifies you of the
violation by some reasonable means, this is the first time you have
received notice of violation of this License (for any work) from that
copyright holder, and you cure the violation prior to 30 days after
your receipt of the notice.

  Termination of your rights under this section does not terminate the
licenses of parties who have received copies or rights from you under
this License.  If your rights have been terminated and not permanently
reinstated, you do not qualify to receive new licenses for the same
material under section 10.

  9. Acceptance Not Required for Having Copies.

  You are not required to accept this License in order to receive or
run a copy of the Program.  Ancillary propagation of a covered work
occurring solely as a consequence of using peer-to-peer transmission
to receive a copy likewise does not require acceptance.  However,
nothing other than this License grants you permission to propagate or
modify any covered work.  These actions infringe copyright if you do
not accept this License.  Therefore, by modifying or propagating a
covered work, you indicate your acceptance of this License to do so.

  10. Automatic Licensing of Downstream Recipients.

  Each time you convey a covered work, the recipient automatically
receives a license from the original licensors, to run, modify and
propagate that work, subject to this License.  You are not responsible
for enforcing compliance by third parties with this License.

  An "entity transaction" is a transaction transferring control of an
organization, or substantially all assets of one, or subdividing an
organization, or merging organizations.  If propagation of a covered
work results from an entity transaction, each party to that
transaction who receives a copy of the work also receives whatever
licenses to the work the party's predecessor in interest had or could
give under the previous paragraph, plus a right to possession of the
Corresponding Source of the work from the predecessor in interest, if
the predecessor has it or can get it with reasonable efforts.

  You may not impose any further restrictions on the exercise of the
rights granted or affirmed under this License.  For example, you may
not impose a license fee, royalty, or other charge for exercise of
rights granted under this License, and you may not initiate litigation
(including a cross-claim or counterclaim in a lawsuit) alleging that
any patent claim is infringed by making, using, selling, offering for
sale, or importing the Program or any portion of it.

  11. Patents.

  A "contributor" is a copyright holder who authorizes use under this
License of the Program or a work on which the Program is based.  The
work thus licensed is called the contributor's "contributor version".

  A contributor's "essential patent claims" are all patent claims
owned or controlled by the contributor, whether already acquired or
hereafter acquired, that would be infringed by some manner, permitted
by this License, of making, using, or selling its contributor version,
but do not include claims that would be infringed only as a
consequence of further modification of the contributor version.  For
purposes of this definition, "control" includes the right to grant
patent sublicenses in a manner consistent with the requirements of
this License.

  Each contributor grants you a non-exclusive, worldwide, royalty-free
patent license under the contributor's essential patent claims, to
make, use, sell, offer for sale, import and otherwise run, modify and
propagate the contents of its contributor version.

  In the following three paragraphs, a "patent license" is any express
agreement or commitment, however denominated, not to enforce a patent
(such as an express permission to practice a patent or covenant not to
sue for patent infringement).  To "grant" such a patent license to a
party means to make such an agreement or commitment not to enforce a
patent against the party.

  If you convey a covered work, knowingly relying on a patent license,
and the Corresponding Source of the work is not available for anyone
to copy, free of charge and under the terms of this License, through a
publicly available network server or other readily accessible means,
then you must either (1) cause the Corresponding Source to be so
available, or (2) arrange to deprive yourself of the benefit of the
patent license for this particular work, or (3) arrange, in a manner
consistent with the requirements of this License, to extend the patent
license to downstream recipients.  "Knowingly relying" means you have
actual knowledge that, but for the patent license, your conveying the
covered work in a country, or your recipient's use of the covered work
in a country, would infringe one or more identifiable patents in that
country that you have reason to believe are valid.

  If, pursuant to or in connection with a single transaction or
arrangement, you convey, or propagate by procuring conveyance of, a
covered work, and grant a patent license to some of the parties
receiving the covered work authorizing them to use, propagate, modify
or convey a specific copy of the covered work, then the patent license
you grant is automatically extended to all recipients of the covered
work and works based on it.

  A patent license is "discriminatory" if it does not include within
the scope of its coverage, prohibits the exercise of, or is
conditioned on the non-exercise of one or more of the rights that are
specifically granted under this License.  You may not convey a covered
work if you are a party to an arrangement with a third party that is
in the business of distributing software, under which you make payment
to the third party based on the extent of your activity of conveying
the work, and under which the third party grants, to any of the
parties who would receive the covered work from you, a discriminatory
patent license (a) in connection with copies of the covered work
conveyed by you (or copies made from those copies), or (b) primarily
for and in connection with specific products or compilations that
contain the covered work, unless you entered into that arrangement,
or that patent license was granted, prior to 28 March 2007.

  Nothing in this License shall be construed as excluding or limiting
any implied license or other defenses to infringement that may
otherwise be available to you under applicable patent law.

  12. No Surrender of Others' Freedom.

  If conditions are imposed on you (whether by court order, agreement or
otherwise) that contradict the conditions of this License, they do not
excuse you from the conditions of this License.  If you cannot convey a
covered work so as to satisfy simultaneously your obligations under this
License and any other pertinent obligations, then as a consequence you may
not convey it at all.  For example, if you agree to terms that obligate you
to collect a royalty for further conveying from those to whom you convey
the Program, the only way you could satisfy both those terms and this
License would be to refrain entirely from conveying the Program.

  13. Remote Network Interaction; Use with the GNU General Public License.

  Notwithstanding any other provision of this License, if you modify the
Program, your modified version must prominently offer all users
interacting with it remotely through a computer network (if your version
supports such interaction) an opportunity to receive the Corresponding
Source of your version by providing access to the Corresponding Source
from a network server at no charge, through some standard or customary
means of facilitating copying of software.  This Corresponding Source
shall include the Corresponding Source for any work covered by version 3
of the GNU General Public License that is incorporated pursuant to the
following paragraph.

  Notwithstanding any other provision of this License, you have
permission to link or combine any covered work with a work licensed
under version 3 of the GNU General Public License into a single
combined work, and to convey the resulting work.  The terms of this
License will continue to apply to the part which is the covered work,
but the work with which it is combined will remain governed by version
3 of the GNU General Public License.

  14. Revised Versions of this License.

  The Free Software Foundation may publish revised and/or new versions of
the GNU Affero General Public License from time to time.  Such new versions
will be similar in spirit to the present version, but may differ in detail to
address new problems or concerns.

  Each version is given a distinguishing version number.  If the
Program specifies that a certain numbered version of the GNU Affero General
Public License "or any later version" applies to it, you have the
option of following the terms and conditions either of that numbered
version or of any later version published by the Free Software
Foundation.  If the Program does not specify a version number of the
GNU Affero General Public License, you may choose any version ever published
by the Free Software Foundation.

  If the Program specifies that a proxy can decide which future
versions of the GNU Affero General Public License can be used, that proxy's
public statement of acceptance of a version permanently authorizes you
to choose that version for the Program.

  Later license versions may give you additional or different
permissions.  However, no additional obligations are imposed on any
author or copyright holder as a result of your choosing to follow a
later version.

  15. Disclaimer of Warranty.

  THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY
APPLICABLE LAW.  EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT
HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY
OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO,
THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM
IS WITH YOU.  SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF
ALL NECESSARY SERVICING, REPAIR OR CORRECTION.

  16. Limitation of Liability.

  IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MODIFIES AND/OR CONVEYS
THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY
GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE
USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF
DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD
PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS),
EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF
SUCH DAMAGES.

  17. Interpretation of Sections 15 and 16.

  If the disclaimer of warranty and limitation of liability provided
above cannot be given local legal effect according to their terms,
reviewing courts shall apply local law that most closely approximates
an absolute waiver of all civil liability in connection with the
Program, unless a warranty or assumption of liability accompanies a
copy of the Program in return for a fee.

                     END OF TERMS AND CONDITIONS

            How to Apply These Terms to Your New Programs

  If you develop a new program, and you want it to be of the greatest
possible use to the public, the best way to achieve this is to make it
free software which everyone can redistribute and change under these terms.

  To do so, attach the following notices to the program.  It is safest
to attach them to the start of each source file to most effectively
state the exclusion of warranty; and each file should have at least
the "copyright" line and a pointer to where the full notice is found.

    <one line to give the program's name and a brief idea of what it does.>
    Copyright (C) <year>  <name of author>

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU Affero General Public License as published
    by the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Affero General Public License for more details.

    You should have received a copy of the GNU Affero General Public License
    along with this program.  If not, see <https://www.gnu.org/licenses/>.

Also add information on how to contact you by electronic and paper mail.

  If your software can interact with users remotely through a computer
network, you should also make sure that it provides a way for users to
get its source.  For example, if your program is a web application, its
interface could display a "Source" link that leads users to an archive
of the code.  There are many ways you could offer source, and different
solutions will be better for different programs; see section 13 for the
specific requirements.

  You should also get your employer (if you work as a programmer) or school,
if any, to sign a "copyright disclaimer" for the program, if necessary.
For more information on this, and how to apply and follow the GNU AGPL, see
<https://www.gnu.org/licenses/>.
```


# Local Environment Setup
Source: https://docs.honcho.dev/v2/contributing/self-hosting

Set up a local environment to run Honcho for development, testing, or self-hosting

This guide helps you set up a local environment to run Honcho for development, testing, or self-hosting.

## Overview

By the end of this guide, you'll have:

* A local Honcho server running on your machine
* A PostgreSQL database with pgvector extension
* Basic configuration to connect your applications
* A working environment for development or testing

## Prerequisites

Before you begin, ensure you have the following installed:

### Required Software

* **uv** - Python package manager: `pip install uv` (manages Python installations automatically)
* **Git** - [Download from git-scm.com](https://git-scm.com/downloads)
* **Docker** (optional) - [Download from docker.com](https://www.docker.com/products/docker-desktop/)

### Database Options

You'll need a PostgreSQL database with the pgvector extension. Choose one:

* **Local PostgreSQL** - Install locally or use Docker
* **Supabase** - Free cloud PostgreSQL with pgvector
* **Railway** - Simple cloud PostgreSQL hosting
* **Your own PostgreSQL server**

## Docker Setup (Recommended)

The easiest way to get started is using Docker Compose, which handles both the database and Honcho server.

### 1. Clone the Repository

```bash
git clone https://github.com/plastic-labs/honcho.git
cd honcho
```

### 2. Set Up Environment Variables

Copy the example environment file and configure it:

```bash
cp .env.template .env
```

Edit `.env` and set your API keys (if using LLM features):

```bash
# Optional API keys (required for LLM features)
OPENAI_API_KEY=your-openai-api-key
ANTHROPIC_API_KEY=your-anthropic-api-key

# Database will be created automatically by Docker
DB_CONNECTION_URI=postgresql+psycopg://postgres:postgres@database:5432/honcho

# Disable auth for local development
AUTH_USE_AUTH=false
```

### 3. Start the Services

```bash
# Copy the example docker-compose file
cp docker-compose.yml.example docker-compose.yml

# Start PostgreSQL and Honcho
docker compose up -d
```

### 4. Verify It's Working

Check that both services are running:

```bash
docker compose ps
```

Test the Honcho API:

```bash
curl http://localhost:8000/health
```

You should see a response indicating the service is healthy.

## Manual Setup

For more control over your environment, you can set up everything manually.

### 1. Clone and Install Dependencies

```bash
git clone https://github.com/plastic-labs/honcho.git
cd honcho

# Install dependencies using uv (this will also set up Python if needed)
uv sync

# Activate the virtual environment
source .venv/bin/activate  # On Windows: .venv\Scripts\activate
```

### 2. Set Up PostgreSQL

#### Option A: Local PostgreSQL Installation

Install PostgreSQL and pgvector on your system:

**macOS (using Homebrew):**

```bash
brew install postgresql
brew install pgvector
```

**Ubuntu/Debian:**

```bash
sudo apt update
sudo apt install postgresql postgresql-contrib
# Install pgvector extension (see pgvector docs for your version)
```

**Windows:**
Download from [postgresql.org](https://www.postgresql.org/download/windows/)

#### Option B: Docker PostgreSQL

```bash
docker run --name honcho-db \
  -e POSTGRES_DB=honcho \
  -e POSTGRES_USER=postgres \
  -e POSTGRES_PASSWORD=postgres \
  -p 5432:5432 \
  -d pgvector/pgvector:pg15
```

### 3. Create Database and Enable Extensions

Connect to PostgreSQL and set up the database:

```bash
# Connect to PostgreSQL
psql -U postgres

# Create database and enable extensions
CREATE DATABASE honcho;
\c honcho
CREATE EXTENSION IF NOT EXISTS vector;
CREATE EXTENSION IF NOT EXISTS pg_trgm;
\q
```

### 4. Configure Environment

Create a `.env` file with your settings:

```bash
cp .env.template .env
```

Edit `.env` with your configuration:

```bash
# Database connection
DB_CONNECTION_URI=postgresql+psycopg://postgres:postgres@localhost:5432/honcho

# Optional API keys (required for LLM features)
OPENAI_API_KEY=your-openai-api-key
ANTHROPIC_API_KEY=your-anthropic-api-key

# Development settings
AUTH_USE_AUTH=false
LOG_LEVEL=DEBUG
```

### 5. Run Database Migrations

```bash
# Run migrations to create tables
uv run alembic upgrade head
```

### 6. Start the Server

```bash
# Start the development server
fastapi dev src/main.py
```

The server will be available at `http://localhost:8000`.

## Cloud Database Setup

If you prefer to use a managed PostgreSQL service:

### Supabase (Recommended)

1. **Create a Supabase project** at [supabase.com](https://supabase.com)
2. **Enable pgvector extension** in the SQL editor:
   ```sql
   CREATE EXTENSION IF NOT EXISTS vector;
   CREATE EXTENSION IF NOT EXISTS pg_trgm;
   ```
3. **Get your connection string** from Settings > Database
4. **Update your `.env` file** with the connection string

### Railway

1. **Create a Railway project** at [railway.app](https://railway.app)
2. **Add a PostgreSQL service**
3. **Enable pgvector** in the PostgreSQL console
4. **Get your connection string** from the service variables
5. **Update your `.env` file**

## Verify Your Setup

Once your Honcho server is running, verify everything is working:

### 1. Health Check

```bash
curl http://localhost:8000/health
```

### 2. API Documentation

Visit `http://localhost:8000/docs` to see the interactive API documentation.

### 3. Test with SDK

Create a simple test script:

```python
from honcho import Honcho

# Connect to your local instance
client = Honcho(base_url="http://localhost:8000")

# Create a test peer
peer = client.peer("test-user")
print(f"Created peer: {peer.id}")
```

## Connect Your Application

Now that Honcho is running locally, you can connect your applications:

### Update SDK Configuration

```python
# Python SDK
from honcho import Honcho

client = Honcho(
    base_url="http://localhost:8000",  # Your local instance
    api_key="your-api-key"  # If auth is enabled
)
```

```typescript
// TypeScript SDK
import { Honcho } from '@honcho-ai/sdk';

const client = new Honcho({
  baseUrl: 'http://localhost:8000',  // Your local instance
  apiKey: 'your-api-key'  // If auth is enabled
});
```

### Next Steps

* **Explore the API**: Check out the [API Reference](/v2/api-reference/introduction)
* **Try the SDKs**: See our [guides](/v2/guides) for examples
* **Configure Honcho**: Visit the [Configuration Guide](./configuration) for detailed settings
* **Join the community**: [Discord](https://discord.gg/plasticlabs)

## Troubleshooting

### Common Issues

**Database Connection Errors**

* Ensure PostgreSQL is running
* Verify the connection string format: `postgresql+psycopg://...`
* Check that pgvector extension is installed

**API Key Issues**

* Verify your OpenAI and Anthropic API keys are valid
* Check that the keys have sufficient credits/quota

**Port Already in Use**

* Pass a different port to FastAPI or stop other services using port 8000

**Docker Issues**

* Ensure Docker is running
* Check container logs: `docker compose logs`
* Restart containers: `docker compose down && docker compose up -d`

**Migration Errors**

* Ensure the database exists and pgvector is enabled
* Check database permissions
* Run migrations manually: `uv run alembic upgrade head`

### Getting Help

* **GitHub Issues**: [Report bugs](https://github.com/plastic-labs/honcho/issues)
* **Discord**: [Join our community](https://discord.gg/plasticlabs)
* **Documentation**: Check the [Configuration Guide](./configuration) for detailed settings

## Production Considerations

When self-hosting for production, consider:

* **Security**: Enable authentication, use HTTPS, secure your database
* **Scaling**: Use connection pooling, consider load balancing
* **Monitoring**: Set up logging, error tracking, health checks
* **Backups**: Regular database backups, disaster recovery plan
* **Updates**: Keep Honcho and dependencies updated


# Architecture & Intuition
Source: https://docs.honcho.dev/v2/documentation/core-concepts/architecture

Understanding Honcho's core concepts and data model.

<Note> The goal of this page is to build an intuition for the primitives in Honcho and how they fit together </Note>

Honcho has 3 main components that work together to manage agent identity and context.

* **The Storage API**: The Memory layer for storing interaction history for your agents
* **The Deriver**: The background processing layer that builds representations of users and agents
* **The Dialectic API**: The natural language API for chatting with representations

Below we'll deep dive into these different areas, discussing the data
primitives, the flow of data through the system, artifacts Honcho produces, and
how to use them.

## Data Model

Honcho has a hierarchical data model centered around the entities below.

```mermaid
 graph TD
      W[Workspaces] -->|have| P[Peers]
      W -->|have| S[Sessions]

      S -->|have| SM[Messages]

      P <-.->|many-to-many| S

      style W fill:#FF5A7E,stroke:#333,stroke-width:2px,color:#fff
      style P fill:#e1f5fe,stroke:#0277bd,color:#000
      style S fill:#f3e5f5,stroke:#7b1fa2,color:#000
      style SM fill:#e8f5e9,stroke:#2e7d32,color:#000
```

There are `Workspaces` at the top that contain `Peers` and `Sessions`. A `Peer`
can be part of many `Sessions` and a `Session` can have many `Peers`. `Sessions`
hold messages that are sent by `Peers`.

### <Icon icon="building" /> Workspaces

Workspaces are the top-level containers that provide complete isolation between
different applications or environments; they essentially serve as a namespace
to isolate different workloads or environments

**Key Features:**

* **Isolation**: Complete data separation between workspaces
* **Multi-tenancy**: Support multiple applications or environments
* **Configuration**: Workspace-level settings and metadata
* **Access Control**: Authentication scoped to workspace level

**Use Cases:**

* Separate development/staging/production environments
* Multi-tenant SaaS applications
* Different product lines or use cases
* Complete data separation between teams

***

### <Icon icon="user" /> Peers

Honcho has a Peer-Centric Architecture: Peers are the most important entity within Honcho, with everything revolving around Peers and their representations.

Peers represent individual users, agents, or entities in a workspace. They are
the primary subjects for memory and context management. Treating humans and
agents the same lets us support arbitrary combinations of Peers for
multi-agent or group chat scenarios.

**Key Features:**

* **Identity**: Unique identifier within a workspace
* **Memory Storage**: Personal memory and context accumulation
* **Configuration**: Per-peer behavioral settings
* **Cross-Session Context**: Memory persists across all sessions

**Use Cases:**

* Individual users in chatbot applications
* AI agents interacting with users or other agents
* Customer profiles in support systems
* Student profiles in educational platforms
* NPCs in role-playing games

***

### <Icon icon="message" /> Sessions

Sessions represent individual conversation threads or interaction contexts between peers.

**Key Features:**

* **Multi-Peer**: Support multiple peers in a single session
* **Temporal Boundaries**: Clear start/end to conversation threads
* **Context Scoping**: Session-specific memory and context
* **Configuration**: Session-level behavioral controls

**Use Cases:**

* Individual chat conversations
* Support tickets
* Meeting transcripts
* Learning sessions
* Single-Peer onboarding sessions where data is imported from an external source

***

### <Icon icon="envelope" /> Messages

Messages are the fundamental units of interaction within sessions. They may
also be used to ingest information of any kind that is not related to a specific interaction, but provides
important context for a peer (emails, docs, files, etc.). Simple make a session
with a single peer and structure the data as messages.

**Key Features:**

* **Rich Content**: Support for text, metadata, and structured data
* **Attribution**: Clear association with sending peer
* **Ordering**: Chronological sequence within sessions
* **Processing**: Automatic background analysis and insight derivation

**Message Types:**

* User messages
* AI responses
* System notifications
* Rich media content
* User actions (clicked, reacted, etc.)
* File uploads (PDFs, text files, JSON documents)

## Deriver

At the core of developing representations of Peers, we have the Deriver. The
Deriver refers to a set of processes in Honcho that enqueue new messages sent
by peers and reasons over them to extract facts, insights, and context.

Depending on the configuration of a `Peer` or `Session`, the deriver will behave
differently and update different representations.

Facts derived here are used in the Dialectic chat endpoint to generate
context-aware responses that can correctly reference both concrete facts
extracted from messages and social insights deduced from facts, tone, and
opinion.

<Info>
  Deriver tasks are processed in parallel, but tasks affecting the same peer representation will always be processed serially in order of message creation, so as to properly understand their cumulative effect.
</Info>

There are two types of tasks that the deriver currently does:

* **Representation Tasks**: Generate/update peer representations
* **Summary Tasks**: Generate conversation summaries

### Peer Representations

Peer representations are more of an abstract concept, as they are made up of
various pieces of data stored throughout Honcho. There are however
multiple types of representations that Honcho can produce.

Honcho handles both **local** and **global** representations of Peers, where
**local** representations are specific to a single Peer's view of another Peer,
while Global Representations are based on any message ever produced by a Peer.

<img src="https://mintcdn.com/plasticlabs/lVyHfvNDd8wveJyM/images/local-vs-global-reps.png?maxW=2054&auto=format&n=lVyHfvNDd8wveJyM&q=85&s=059c828c1a4ed4fa42eaa781d6b8fcc7" alt="Peer Representations" width="2054" height="1150" data-path="images/local-vs-global-reps.png" srcset="https://mintcdn.com/plasticlabs/lVyHfvNDd8wveJyM/images/local-vs-global-reps.png?w=280&maxW=2054&auto=format&n=lVyHfvNDd8wveJyM&q=85&s=df8f8dca6ef59aef14e0c193ae873b76 280w, https://mintcdn.com/plasticlabs/lVyHfvNDd8wveJyM/images/local-vs-global-reps.png?w=560&maxW=2054&auto=format&n=lVyHfvNDd8wveJyM&q=85&s=e403072624e13427bfa764facafd8863 560w, https://mintcdn.com/plasticlabs/lVyHfvNDd8wveJyM/images/local-vs-global-reps.png?w=840&maxW=2054&auto=format&n=lVyHfvNDd8wveJyM&q=85&s=557bf682c2f896614c5ebe97fd25fa13 840w, https://mintcdn.com/plasticlabs/lVyHfvNDd8wveJyM/images/local-vs-global-reps.png?w=1100&maxW=2054&auto=format&n=lVyHfvNDd8wveJyM&q=85&s=f553e52156626e7d3a20320cb3f9b46c 1100w, https://mintcdn.com/plasticlabs/lVyHfvNDd8wveJyM/images/local-vs-global-reps.png?w=1650&maxW=2054&auto=format&n=lVyHfvNDd8wveJyM&q=85&s=4694ad2a97d84a8b58191060031bcf89 1650w, https://mintcdn.com/plasticlabs/lVyHfvNDd8wveJyM/images/local-vs-global-reps.png?w=2500&maxW=2054&auto=format&n=lVyHfvNDd8wveJyM&q=85&s=60a7088fced71dc3e35e0f3b6d160015 2500w" data-optimize="true" data-opv="2" />

Everything is framed with regards to perspective. Alice owns her own global
representation, but she also maintains a local representation of Bob based on what she
observes and similarly Bob has a global representation of himself and local
representation of Alice. So in the example above, when Alice sends a message to
Bob it triggers an update to both Alice's global representation of herself and Bob's local
representation of Alice.

If Alice were to have another conversation with a different Peer, Nico, and
sent them a message, this action would trigger an update to Alice's Global
Representation and Nico's local representation of Alice. Bob's local
representation of Alice would not change since Bob would never receive that
message.

<Note>By default, local representations are disabled, but can be enabled in a
Peer or Session level configuration</Note>

Depending on the use case, a developer may choose to only use global
representation, only use local, or a combination.

### Summary

Summary tasks create conversation summaries. Periodically, a
"short" summary will be created for each session as messages are added -- every
20 messages by default. "Long" summaries are created every 60 messages by
default and maintain a total overview of the session by including the previous
summary in a recursive fashion. These summaries are accessed in the
`get_context` endpoint along with recent messages, allowing developers to
easily fetch everything necessary to generate the next LLM completion for an
agent.

The system defaults are also the checkpoints used on the managed version of
Honcho hosted at [https://api.honcho.dev](https://api.honcho.dev)

## Dialectic API

The Dialectic API is one of the most integral components of Honcho and acts as
the main way to leverage Peer Representations. By using the `/chat` endpoint,
developers can directly talk to Honcho about any Peer in a workspace to get
insights into the psychology of a Peer and help them steer their behavior.

This allows us to use this one endpoint for a wide variety of use cases. Model
steering, personalization, hydrating a prompt, etc. Additionally, since the
endpoint works through natural language, a developer can allow an agent to
backchannel directly with Honcho, via MCP or a direct API call.

Developers should frame the Dialectic as talking to an expert on the Peer rather than addressing the Peer itself, meaning:

```python
alice.chat("What is the user's mood today?") # ✅ Ideal

alice.chat("What is alice's mood today?") # ✅ Works -- but make sure to consider what peer "Alice" has been saying in their messages about name/identity.

alice.chat("What is your mood today?") # ❌ Likely to fail -- the dialectic agent may conflate itself and the user.
```

<Note>
  Think of Dialectic Chat as an assisting agent that your main agent can consult for contextual information about any actor in your application.
</Note>

## Next Steps

<CardGroup cols={2}>
  <Card title="Platform SDK" icon="code" href="/v2/documentation/platform/sdk">
    Learn how to use the SDK to interact with the data model
  </Card>

  <Card title="Glossary" icon="book" href="/v2/documentation/core-concepts/glossary">
    Reference for all technical terms and concepts
  </Card>

  <Card title="API Reference" icon="play" href="/v2/api-reference/introduction">
    Detailed API documentation and examples
  </Card>

  <Card title="Quickstart" icon="rocket" href="/v2/documentation/introduction/quickstart">
    Get started with your first integration
  </Card>
</CardGroup>


# Configuration
Source: https://docs.honcho.dev/v2/documentation/core-concepts/configuration

Customizing how Honcho handles peers and sessions

Entities in Honcho can sometimes be configured to change the behavior of the deriver, which is responsible for generating and storing facts, summaries, and user representations.

These configurations can be set at the peer, session, and session-peer level (AKA the state of a peer within a specific session).

### Peer Configuration

By default, all peers are "observed" by Honcho. This means that Honcho will derive facts from messages sent by the peer and generate a representation of them. In most cases, this is why you use Honcho! However, sometimes an application requires a peer that should not be observed: for example, an assistant or game NPC that your program will never need to ask questions about.

You may therefore disable observation of a peer by setting the `observe_me` flag in their configuration to `false`.

If the peer has a session-level configuration, it will override this configuration. If the flag is not set, or is set to `true`, the peer will be observed.

<CodeGroup>
  ```python Python
  from honcho import Honcho

  # Initialize client
  honcho = Honcho()

  # Create peer with configuration
  peer = honcho.peer("my-peer", config={"observe_me": False})

  # Change peer's configuration
  peer.set_peer_config({"observe_me": True})

  # Note: creating the same peer again will also replace the configuration
  peer = honcho.peer("my-peer", config={"observe_me": False})
  ```

  ```typescript TypeScript
  import { Honcho } from "@honcho-ai/sdk";

  (async () => {
      // Initialize client
      const honcho = new Honcho({});

      // Create peer with configuration
      const peer = await honcho.peer("my-peer", { config: { observe_me: false } });

      // Change peer's configuration
      await peer.setPeerConfig({ observe_me: true });

      // Note: creating the same peer again will also replace the configuration
      await honcho.peer("my-peer", { config: { observe_me: false } });
  })();
  ```
</CodeGroup>

### Session Configuration

By default, all sessions have the deriver enabled, much like peers. You may create a session that escapes the deriver's watchful eye by setting the `deriver_disabled` flag to `true`. You can update the flag by calling `get_or_create` on the session with a new configuration.

<CodeGroup>
  ```python Python
  from honcho import Honcho

  # Initialize client
  honcho = Honcho()

  # Create session with configuration
  session = honcho.session("my-session", config={"deriver_disabled": True})
  ```

  ```typescript TypeScript
  import { Honcho } from "@honcho-ai/sdk";

  (async () => {
      // Initialize client
      const honcho = new Honcho({});

      // Create session with configuration
      const session = await honcho.session("my-session", { config: { deriver_disabled: true } });
  })();
  ```
</CodeGroup>

### Session-Peer Configuration

Configuration at the session-peer level is the most common use case for configuration flags. You will often want to arrange a session such that certain peers observe others in order to form "local representations" of them. There are two flags that can be set at the session-peer level:

* `observe_me`: Whether this peer should *be observed* by others in the session. By default, this is `true`. This overrides the peer-level `observe_me` flag.

* `observe_others`: Whether this peer should produce local representations of others in the session. By default, this is `false`. Other peers will only be observed if their `observe_me` flag is `true`.

You can combine these flags across multiple peers to arrange any possible permutation of directional observation. Note that in the default case, no local representations are produced. To produce local representations, you must set the `observe_others` flag to `true` for at least one peer in the session and at least one other peer must have their `observe_me` flag set to `true`.

Many applications will work best without local representations, preferring to chat with Honcho's top-down representation of each peer. Only enable local representations via the `observe_others` flag if you are doing advanced reasoning on user perspectives.

<img src="https://mintcdn.com/plasticlabs/lVyHfvNDd8wveJyM/images/local-vs-global-reps.png?maxW=2054&auto=format&n=lVyHfvNDd8wveJyM&q=85&s=059c828c1a4ed4fa42eaa781d6b8fcc7" alt="Peer Representations" width="2054" height="1150" data-path="images/local-vs-global-reps.png" srcset="https://mintcdn.com/plasticlabs/lVyHfvNDd8wveJyM/images/local-vs-global-reps.png?w=280&maxW=2054&auto=format&n=lVyHfvNDd8wveJyM&q=85&s=df8f8dca6ef59aef14e0c193ae873b76 280w, https://mintcdn.com/plasticlabs/lVyHfvNDd8wveJyM/images/local-vs-global-reps.png?w=560&maxW=2054&auto=format&n=lVyHfvNDd8wveJyM&q=85&s=e403072624e13427bfa764facafd8863 560w, https://mintcdn.com/plasticlabs/lVyHfvNDd8wveJyM/images/local-vs-global-reps.png?w=840&maxW=2054&auto=format&n=lVyHfvNDd8wveJyM&q=85&s=557bf682c2f896614c5ebe97fd25fa13 840w, https://mintcdn.com/plasticlabs/lVyHfvNDd8wveJyM/images/local-vs-global-reps.png?w=1100&maxW=2054&auto=format&n=lVyHfvNDd8wveJyM&q=85&s=f553e52156626e7d3a20320cb3f9b46c 1100w, https://mintcdn.com/plasticlabs/lVyHfvNDd8wveJyM/images/local-vs-global-reps.png?w=1650&maxW=2054&auto=format&n=lVyHfvNDd8wveJyM&q=85&s=4694ad2a97d84a8b58191060031bcf89 1650w, https://mintcdn.com/plasticlabs/lVyHfvNDd8wveJyM/images/local-vs-global-reps.png?w=2500&maxW=2054&auto=format&n=lVyHfvNDd8wveJyM&q=85&s=60a7088fced71dc3e35e0f3b6d160015 2500w" data-optimize="true" data-opv="2" />

You can dynamically change the configuration of a session-peer by calling `set_peer_config` on the session with the peer and the configuration you want to set.

<CodeGroup>
  ```python Python
  from honcho import Honcho

  # Initialize client
  honcho = Honcho()

  # Create session
  session = honcho.session("my-session")

  # Create peers
  alice = honcho.peer("alice")
  bob = honcho.peer("bob")

  # Add peers to session with default configuration
  session.add_peers([alice, bob])

  # Add another peer to the session with a custom configuration
  charlie = honcho.peer("charlie")
  session.add_peers([charlie, {"observe_me": False, "observe_others": True}])

  # Set session-peer configuration
  session.set_peer_config(alice, {"observe_others": True})
  session.set_peer_config(bob, {"observe_me": False})

  # Get session-peer configuration
  charlie_config = session.get_peer_config(charlie)
  print(charlie_config)
  ```

  ```typescript TypeScript
  import { Honcho } from "@honcho-ai/sdk";

  (async () => {
      // Initialize client
      const honcho = new Honcho({});

      // Create session
      const session = await honcho.session("my-session");

      // Create peers
      const alice = await honcho.peer("alice");
      const bob = await honcho.peer("bob");

      // Add peers to session
      await session.addPeers([alice, bob]);

      // Add another peer to the session with a custom configuration
      const charlie = await honcho.peer("charlie");
      await session.addPeers([charlie, { observe_me: false, observe_others: true }]);

      // Set session-peer configuration
      await session.setPeerConfig(alice, { observe_others: true });
      await session.setPeerConfig(bob, { observe_me: false });

      // Get session-peer configuration
      const charlieConfig = await session.getPeerConfig(charlie);
      console.log(charlieConfig);
  })();
  ```
</CodeGroup>


# Features
Source: https://docs.honcho.dev/v2/documentation/core-concepts/features

Key features and capabilities of Honcho

This page is a quick overview of the features within Honcho. In-depth
guides are available for each feature in the [Spellbooks - Design Patterns](../../guides/overview#design-patterns) section.

### Local vs Global Representation

Peers in Honcho are abstract entities that can represent humans, agents, or NPCs. Honcho has a two-layer approach to forming representations of Peers.

* **Global Representation**: Representation owned by a Peer that is constructed from everything the Peer has sent within Honcho.
* **Local Representation**: The representation that a Peer forms of other Peers, based on the messages those other Peers have sent (as observed by the Peer forming the representation).
* At the Session level, you can configure which Peers are able to observe messages from other Peers in that Session. This determines which Peers form representations of others within the Session.

### Queue Status

To help developers understand when a Peer's representation is fully up to date, Honcho exposes the ability to poll the status of Peer-centric queues that construct representations.

* If no Session is specified, the queue status reflects pending work for the Peer's global representation.
* If a Session is specified, the queue status reflects pending work for the Peer's working representation in that Session.

### Search

Honcho implements a powerful search endpoint that allows you to search for messages across a workspace, session, or peer with complex [filters](/v2/guides/using-filters).

The search process combines full-text and semantic search using reciprocal rank fusion. By default, all messages ingested into Honcho have embeddings generated and stored in the database, enabling semantic search -- if this feature is disabled, the search process will only use full-text search.

Results are returned in the form of a list of Message objects, and you may choose how many results to return. The default is 10 results, with a maximum of 100.

In the SDK, search is available on `Workspace`, `Session`, and `Peer` objects, and an optional `filters` parameter may be used to apply a narrower search scope such as a time range or developer-defined metadata attached to messages.

Note that results are not ordered by recency, only relevance. Results can be sorted by timestamp or a filter on the `created_at` field can limit results to recent messages.

[Look here for examples of how to use search in the SDK](/v2/guides/search).

### Scoped API Keys

Builders can create scoped API keys to control access to different resources within Honcho.

* **Workspace-Level Keys**: Access to everything scoped to a Workspace.
* **Peer-Level Keys**: Access to everything scoped to a Peer.
* **Session-Level Keys**: Access to everything scoped to a Session.

### Get Context

Honcho provides a powerful context retrieval feature that delivers formatted conversation context from sessions, making it easy to integrate with LLMs like OpenAI, Anthropic, and others.

* By default, the context includes a blend of summary and messages which covers the entire history of the session.
* Summaries are generated automatically at intervals, and recent messages are included based on your specified token budget for the context.
* You can set any token limit, and if you prefer, you can disable summaries so that the context consists entirely of the most recent messages up to your chosen limit.


# Terminology
Source: https://docs.honcho.dev/v2/documentation/core-concepts/glossary

Glossary of AI and Honcho Specific Terms

## AI Development Basics

Essential terms for developers new to building AI applications.

**LLM (Large Language Model)**  The AI model that generates text responses,
like GPT-4, Claude, or Llama. Think of it as the "brain" that powers your
chatbot or AI assistant.

**Prompt**  The text you send to an AI model to get a response. This includes
user messages, system instructions, and any context you provide.

**Token**  How AI models count and limit text. Roughly 1 token = 0.75 words.
Models have token limits (like 4,000 or 128,000 tokens) that determine how much
text they can process at once.

**Context Window**  The maximum amount of text an AI model can "remember" in
one conversation. Once you exceed this limit, the model starts "forgetting"
earlier parts of the conversation.

**Embedding**  Converting text into numerical vectors that computers can
understand and compare. Enables "smart search" that finds similar content based
on meaning, not just keywords.

**Semantic Search**  Search based on meaning rather than exact keyword
matching, often using embeddings.

**Agent**  An AI system that can take actions and make decisions, not just
generate text responses. Agents can use tools, call APIs, and interact with
external systems.

## Honcho Terms

**Global Representation**  Derived context of a specific peer, synthesizing
insights from interactions across all sessions, including arbitrary data
ingested by this specific peer. With arbitrary data, a global representation
can be made independent of sessions.

**Local Representation**  One peer's persistent context of another based on
observed interactions/messages.

## Cognitive Science Terms

Cognitive science terms that are used throughout the inspiration and
implementation of Honcho

**Theory of Mind**  The ability of a computer to understand, remember, and
interact with its own mind, enabling it to form representations of the world
and make decisions based on its own knowledge and behavior.

**Social Cognition** The mental processes by which we perceive, interpret, and
respond to information about others and social situations. It includes the
encoding, storage, retrieval, and application of social knowledge.

**Cognitive Architecture** In CogSci, frameworks describing fixed structures & mechanisms underlying
human cognition. Such frameworks aim to explain how various components of the mind--perception, memory,
reasoning, learning, etc--combine to produce intelligent behavior across diverse environments. In
AI, it’s a computational implementation of these theories--a designed framework to replicate human
cognitive functions.

**Predictive Coding** A theory in CogSci proposing the brain is an active prediction machine,
continually generating & updating internal world models to anticipate sensory input, rather than
passively receiving it--closely linked to Bayesian brain hypotheses, which hold that the brain
interprets the world probabilistically, weighing prior knowledge against new evidence to minimize
uncertainty.


# Summarizer
Source: https://docs.honcho.dev/v2/documentation/core-concepts/summarizer

How Honcho creates summaries of conversations

Almost all agents require, in addition to personalization and memory, a way to quickly prime a context window with a summary of the conversation (in Honcho, this is equivalent to a `session`). The general strategy for summarization is to combine a list of recent messages verbatim with a compressed LLM-generated summary of the older messages not included. Implementing this correctly, in such a way that the resulting context is:

* Exhaustive: the combination of recent messages and summary should cover the entire conversation
* Dynamically sized: the tokens used on both summary and recent messages should be malleable based on desired token usage
* Performant: while creation of the summary by LLM introduces necessary latency, this should never add latency to an arbitrary end-user request

...is a non-trivial problem. Summarization should not be necessary to re-implement for every new agent you build, so Honcho comes with a built-in solution.

### Creating Summaries

Honcho already has an asynchronous task queue for the purpose of deriving facts from messages. This is the ideal place to create summaries where they won't add latency to a message. Currently, Honcho has two configurable summary types:

* Short summaries: by default, enqueued every 20 messages and given a token limit of 1000
* Long summaries: by default, enqueued every 60 messages and given a token limit of 4000

Both summaries are designed to be exhaustive: when enqueued, they are given the *prior* summary of their type plus every message after that summary. This recursive compression process naturally biases the summary towards recent messages while still covering the entire conversation.

For example, if message 160 in a conversation triggers a short summary, as it would with default settings, the summary task would retrieve the prior short summary (message 140) plus messages 141-160. It would then produce a summary of messages 0-160 and store that in the short summary slot on the session. Every session has a single slot for each summary type: new summaries replace old ones.

It's important to keep in mind that summary tasks run in the background and are not guaranteed to complete before the next message. However, they are guaranteed to complete in order, so that if a user saves 100 messages in a single batch, the short summary will first be created for messages 0-20, then 21-40, and so on, in our desired recursive way.

### Retrieving Summaries

Summaries are retrieved from the session by the `get_context` method. This method has two parameters:

* `summary`: A boolean indicating whether to include the summary in the return type. The default is true.
* `tokens`: An integer indicating the maximum number of tokens to use for the context. **If not provided, `get_context` will retrieve as many tokens as are required to create exhaustive conversation coverage.**

The return type is simply a list of recent messages and a summary if the flag is used. These two components are dynamically sized based on the token limit. Combined, they will always be below the given token limit. Honcho reserves 60% of the context size for recent messages and 40% for the summary.

There's a critical trade-off to understand between exhaustiveness and token usage. Let's go through some scenarios:

* If the *last message* contains more tokens than the context token limit, no summary *or* message list is possible -- both will be empty.

* If the *last few messages* contain more tokens than the context token limit, no summary is possible -- the context will only contain the last 1 or 2 messages that fit in the token limit.

* If the summaries contain more tokens than the context token limit, no summary is possible -- the context will only contain the X most recent messages that fit in the token limit. Note that while summaries will often be smaller than their token limits, avoiding this scenario means passing a higher token limit than the Honcho-configured summary size(s). For this reason, the default token limit for `get_context` is a few times larger than the configured long summary size.

The above scenarios indicate where summarization is not possible -- therefore, the context retrieved will almost certainly **not** be exhaustive.

Sometimes, gaps in context aren't an issue. In these cases, it's best to pass a reasonable token limit depending on your needs. Other cases demand exhaustive context -- don't pass a token limit and just let Honcho retrieve the ideal combination of summary and recent messages. Finally, if you don't care about the conversation at large and just want the last few messages, set `summary` to false and `tokens` to some multiple of your desired message count. Note that context messages are not paginated, so there's a hard limit on the number of messages that can be retrieved (currently 100,000 tokens).

As a final note, remember that summaries are generated asynchronously and therefore may not be available immediately. If you batch-save a large number of messages, assume that summaries will not be available until those messages are processed, which can take seconds to minutes depending on the number of messages and the configured LLM provider. Exhaustive `get_context` calls performed during this time will likely just return the messages in the session.


# Honcho
Source: https://docs.honcho.dev/v2/documentation/introduction/overview

Go beyond memory to agents with actual social intelligence

When building agents developers often run into the same walls:

> "My agent forgets everything between chats"

You need memory: session management, message storage, context handling. It's table stakes, but surprisingly complex to get right.

> "My agent treats everyone exactly the same"

You need personalization: user modeling, preference learning, behavioral adaptation. Now you're building a [social cognition](../core-concepts/glossary#cognitive-science-terms) engine

> "I'm writing infrastructure instead of features"

You need Honcho

<img src="https://mintcdn.com/plasticlabs/lVyHfvNDd8wveJyM/images/agent_hierarchy.png?maxW=3004&auto=format&n=lVyHfvNDd8wveJyM&q=85&s=81fe084f4ee9a4683cf1104a8f6060b8" alt="Honcho's Hiearchy of Agents" width="3004" height="1908" data-path="images/agent_hierarchy.png" srcset="https://mintcdn.com/plasticlabs/lVyHfvNDd8wveJyM/images/agent_hierarchy.png?w=280&maxW=3004&auto=format&n=lVyHfvNDd8wveJyM&q=85&s=1fd3c587e9170e6e71cb60cbb5f2ddef 280w, https://mintcdn.com/plasticlabs/lVyHfvNDd8wveJyM/images/agent_hierarchy.png?w=560&maxW=3004&auto=format&n=lVyHfvNDd8wveJyM&q=85&s=fa396eadc1d885983bfcf6e3e8be003e 560w, https://mintcdn.com/plasticlabs/lVyHfvNDd8wveJyM/images/agent_hierarchy.png?w=840&maxW=3004&auto=format&n=lVyHfvNDd8wveJyM&q=85&s=0d241b9b11bcee9a8b050308413ea06a 840w, https://mintcdn.com/plasticlabs/lVyHfvNDd8wveJyM/images/agent_hierarchy.png?w=1100&maxW=3004&auto=format&n=lVyHfvNDd8wveJyM&q=85&s=181773eda2845a5c4dedb433803ef996 1100w, https://mintcdn.com/plasticlabs/lVyHfvNDd8wveJyM/images/agent_hierarchy.png?w=1650&maxW=3004&auto=format&n=lVyHfvNDd8wveJyM&q=85&s=39b82ca9164792b30e3bde6e81406c0f 1650w, https://mintcdn.com/plasticlabs/lVyHfvNDd8wveJyM/images/agent_hierarchy.png?w=2500&maxW=3004&auto=format&n=lVyHfvNDd8wveJyM&q=85&s=5eda3c1b216ef40f529571e0fa12ae0c 2500w" data-optimize="true" data-opv="2" />

Honcho delivers production-ready memory infrastructure from day one. Store
conversations, manage sessions, get perfectly formatted context for any LLM.
But here's the magic: while your agents are chatting, Honcho is learning. It
builds Theory of Mind models automatically, transforming raw conversations into
rich psychological understanding.

```python
# Start simple - just add messages
session.add_messages([alice.message("I learn best with examples")])

# Get powerful - query user psychology
insight = peer.chat("How should I explain this concept?")
# > "This user learns best through concrete examples..."
```

Your agents evolve from goldfish to counselor, on the same infrastructure. That's Honcho.

Designed for developers and agents alike:

* **Natural Language Queries**: Chat with Honcho in natural language via the [Dialectic API](../core-concepts/glossary#storage-%26-processing) and let agents backchannel
* **Automatic Context Management**: Smart summarization that respects token limits
* **Native multi-agent support**: Break out of User/Assistant Paradigms and build complex multi-agent systems
* **Agent-first interfaces**: MCP connections and APIs designed for agents to consume and use as tools
* **Provider Agnostic**: Works with any LLM or Agent Framework

## How It Works

### Storage

Developers use Honcho to store information about their users and application via
two integrated layers:

<img src="https://mintcdn.com/plasticlabs/lVyHfvNDd8wveJyM/images/basic_honcho_flowchart.png?maxW=2426&auto=format&n=lVyHfvNDd8wveJyM&q=85&s=4ffe51d300a9cbc51e1541fa98b69412" alt="Basic Honcho Flowchart" width="2426" height="1056" data-path="images/basic_honcho_flowchart.png" srcset="https://mintcdn.com/plasticlabs/lVyHfvNDd8wveJyM/images/basic_honcho_flowchart.png?w=280&maxW=2426&auto=format&n=lVyHfvNDd8wveJyM&q=85&s=5cc9a802bbccddfeda80c184c6d5625f 280w, https://mintcdn.com/plasticlabs/lVyHfvNDd8wveJyM/images/basic_honcho_flowchart.png?w=560&maxW=2426&auto=format&n=lVyHfvNDd8wveJyM&q=85&s=7a80d3e96ac08bdae75ff320d71af0fe 560w, https://mintcdn.com/plasticlabs/lVyHfvNDd8wveJyM/images/basic_honcho_flowchart.png?w=840&maxW=2426&auto=format&n=lVyHfvNDd8wveJyM&q=85&s=46188a63580cd76bea516a96fdd7dc85 840w, https://mintcdn.com/plasticlabs/lVyHfvNDd8wveJyM/images/basic_honcho_flowchart.png?w=1100&maxW=2426&auto=format&n=lVyHfvNDd8wveJyM&q=85&s=eb26dfdb720598bdd077ab20d30d11ce 1100w, https://mintcdn.com/plasticlabs/lVyHfvNDd8wveJyM/images/basic_honcho_flowchart.png?w=1650&maxW=2426&auto=format&n=lVyHfvNDd8wveJyM&q=85&s=ac76cc9f3c738a558b6d17258ebb59e1 1650w, https://mintcdn.com/plasticlabs/lVyHfvNDd8wveJyM/images/basic_honcho_flowchart.png?w=2500&maxW=2426&auto=format&n=lVyHfvNDd8wveJyM&q=85&s=cea86ef9a2d16fb994bed3e8c9095617 2500w" data-optimize="true" data-opv="2" />

**Memory Layer**: Captures all user interactions - messages, preferences, and
behavioral patterns - in a peer-centric data model that scales from individual
conversations to complex multi-agent scenarios. This also queues up messages for
the reasoning layer to process.

**Reasoning Layer**: Continuously analyzes stored interactions to build
psychological profiles using [theory of mind](glossary#theory-of-mind)
inference, extracting patterns about communication style, decision-making
preferences, and mental models.

### Retrieval

Once data is stored and generated within Honcho, the API exposes several
different ways to retrieve and use those insights.

**[Dialectic API](../guides/dialectic-endpoint)**: This is the
flagship endpoint that allows developers to send natural language queries to
Honcho to chat with the representation of each user in your system to get
dynamic, in-context actionable insights.

Example Queries

* "What's the best way to explain technical concepts to this user?"
* "Is this user more task-oriented or relationship-oriented?"
* "What time of day is this user most engaged?"
* "How does this user prefer to receive feedback?"
* "What are this user's core values based on our conversations?"

**[Get Context](../guides/get-context)**: This endpoint abstracts context window
constraints and continuously retrieves the most relevant and recent data from a
conversation. Provide a token budget and Honcho will rturn a combination of
summaries and messages that pvoide session context. Use this for creating
long-running conversations. We crafted our summaries to provide the most
[coverage of a session possible](../core-concepts/summarizer).

**[Search](../guides/search)**: This endpoint allows you to search across Honcho
for relevant messages either at the workspace, peer, or session level. This
endpoint uses a hybrid search strategy that combines text search and cosine
similarity.

**[Working Representations](../guides/working-rep)**: Get a cached, snapshot
of a user in the context of a session. Instead of waiting for an LLM to
synthesize an in-context response via the Dialectic endpoint, use this to get
recent insights you can plug into your context window.

## Ideal For

**Personalized AI assistants** that need to understand individual psychology, not just remember conversations.

**Customer-facing agents** that must adapt their approach based on user communication preferences and emotional context.

**Multi-agent systems** where AI needs to understand human collaborators' working styles and decision-making patterns.

**NPCs** where you want autonomous agents with a rich and deep personality that isn't the average sycophantic llm

## Getting Started

Ready to integrate Honcho into your application?

<CardGroup cols={2}> <Card title="Quickstart Guide" icon="rocket" href="/v2/documentation/introduction/quickstart"> Get up and running with
Honcho in minutes </Card> <Card title="Core Concepts" icon="brain" href="/v2/documentation/core-concepts/glossary"> Understand Honcho's
fundamental concepts </Card> </CardGroup>

## Community & Support

* **GitHub**: [plastic-labs/honcho](https://github.com/plastic-labs/honcho)
* **Discord**: [Join our community](http://discord.gg/plasticlabs)
* **Issues**: Report bugs and request features on GitHub


# Quickstart
Source: https://docs.honcho.dev/v2/documentation/introduction/quickstart

Start building with Honcho in under 5 minutes.

For production-level use, Honcho offers two powerful ways to leverage ambient personalization: our managed platform and our open source solution. Read further if you want to explore the quickstart demo.

<CardGroup cols={2}>
  <Card title="Honcho Platform" icon="cloud" href="https://app.honcho.dev">
    Fully managed, hassle-free solution with one-click deployment
  </Card>

  <Card title="Honcho Open Source" icon="github" href="https://github.com/plastic-labs/honcho">
    Self-hosted, fully customizable, and open source
  </Card>
</CardGroup>

# Getting Started

Have your project use Honcho's ambient personalization capabilities in just a few steps. No signup required!

<Info>
  By default, the SDK uses the demo server hosted at demo.honcho.dev. The demo server is meant for quick experimentation and the data is cleared on a regular basis. Do not use for production applications.

  For production use:

  1. Get your API key at [app.honcho.dev/api-keys](https://app.honcho.dev/api-keys)
  2. Set `environment="production"` and provide your `api_key`
</Info>

## 1. Install the SDK

<CodeGroup>
  ```bash Python (uv)
  uv add honcho-ai
  ```

  ```bash Python (pip)
  pip install honcho-ai
  ```

  ```bash TypeScript (npm)
  npm install @honcho-ai/sdk
  ```

  ```bash TypeScript (yarn)
  yarn add @honcho-ai/sdk
  ```

  ```bash TypeScript (pnpm)
  pnpm add @honcho-ai/sdk
  ```
</CodeGroup>

## 2. Initialize the Client

The Honcho client is the main entry point for interacting with Honcho's API. By default, it uses the demo environment and a default workspace.

### Demo Environment (Default)

<CodeGroup>
  ```python Python
  from honcho import Honcho

  # Initialize client (uses demo environment and default workspace)
  client = Honcho()

  ```

  ```typescript TypeScript
  import { Honcho } from '@honcho-ai/sdk';

  // Initialize client (uses demo environment and default workspace)
  const client = new Honcho({});

  ```
</CodeGroup>

### Production Environment

<CodeGroup>
  ```python Python
  import os
  from honcho import Honcho

  # Production environment with API key
  client = Honcho(
      api_key=os.environ["HONCHO_API_KEY"],
      environment="production",
      # Create a workspace, otherwise set to "default"
      # workspace="your-workspace-id"
  )
  ```

  ```typescript TypeScript
  import { Honcho } from '@honcho-ai/sdk';

  // Production environment with API key
  const client = new Honcho({
      apiKey: process.env.HONCHO_API_KEY!,
      environment: "production",
      // Create a workspace, otherwise set to "default"
      // workspace: "your-workspace-id"
  });
  ```
</CodeGroup>

## 3. Create Peers

Peers represent individual users, AI agents, or any conversational entity in your system:

<CodeGroup>
  ```python Python
  alice = client.peer("alice")
  bob = client.peer("bob")
  ```

  ```typescript TypeScript
  const alice = await client.peer("alice")
  const bob = await client.peer("bob")
  ```
</CodeGroup>

## 4. Create a Session

Sessions are independent conversations that can include multiple peers:

<CodeGroup>
  ```python Python
  session = client.session("session_1")
  session.add_peers([alice, bob])
  ```

  ```typescript TypeScript
  const session = await client.session("session_1")
  await session.addPeers([alice, bob])
  ```
</CodeGroup>

## 5. Add Messages

Add some conversation messages. Honcho automatically learns from these interactions:

<CodeGroup>
  ```python Python
  session.add_messages([
      alice.message("Hi Bob, how are you?"),
      bob.message("I'm good, thank you!"),
      alice.message("What are you doing today after work?"),
      bob.message("I'm going to the gym! I've been trying to get back in shape."),
      alice.message("That's great! I should probably start exercising too."),
      bob.message("You should! I find that evening workouts help me relax."),
  ])
  ```

  ```typescript TypeScript
  await session.addMessages([
      alice.message("Hi Bob, how are you?"),
      bob.message("I'm good, thank you!"),
      alice.message("What are you doing today after work?"),
      bob.message("I'm going to the gym! I've been trying to get back in shape."),
      alice.message("That's great! I should probably start exercising too."),
      bob.message("You should! I find that evening workouts help me relax."),
  ])
  ```
</CodeGroup>

## 6. Query for Insights

Now ask Honcho what it's learned - this is where the magic happens:

<CodeGroup>
  ```python Python
  # Ask what Bob is like
  response = alice.chat("Tell me about Bob's interests and habits")
  print(response)

  # Returns rich context like:
  # "Bob is health-conscious and has been working on getting back in shape.
  # He regularly goes to the gym, particularly in the evenings, and finds
  # exercise helps him relax. He's encouraging about fitness and willing
  # to share advice about workout routines."
  ```

  ```typescript TypeScript
  (async () => {
      // Ask what Bob is like
      const response = await alice.chat("Tell me about Bob's interests and habits");
      console.log(response);

      // Returns rich context like:
      // "Bob is health-conscious and has been working on getting back in shape.
      // He regularly goes to the gym, particularly in the evenings, and finds
      // exercise helps him relax. He's encouraging about fitness and willing
      // to share advice about workout routines."
  })();
  ```
</CodeGroup>

## What Just Happened?

Honcho automatically built rich psychological profiles from just a few messages:

* **Theory of Mind Processing**: Understanding personality, preferences, and patterns
* **Ambient Learning**: No surveys or explicit training - just natural conversation
* **Rich Context**: Far more detailed than simple conversation history

The response isn't just retrieving stored text - it's synthesizing insights about Bob's personality, habits, and communication style.

## Next Steps

This covers the core concepts: **peers**, **sessions**, **messages**, and **dialectic queries**.

* For production use, [sign up for the managed platform](https://app.honcho.dev) or get an [overview here](/v2/documentation/platform/overview).
* For detailed API reference, check out our [SDK documentation](/v2/documentation/platform/sdk).
* For more examples, explore our [guides](/v2/guides).

***


# AI-Powered Honcho Setup
Source: https://docs.honcho.dev/v2/documentation/introduction/vibecoding

Universal starter prompt for building with Honcho

Copy this prompt into Cursor, Claude, or any AI coding assistant to start building with Honcho.

## 🚀 Universal Starter Prompt

```
I want to start building with Honcho - a memory and personalization platform for AI applications.

## Honcho Resources

**Documentation:**
- Main docs: https://docs.honcho.dev
- API Reference: https://docs.honcho.dev/v2/api-reference/introduction
- Quickstart: https://docs.honcho.dev/v2/documentation/introduction/quickstart
- Architecture: https://docs.honcho.dev/v2/documentation/reference/architecture

**Code & Examples:**
- Core repo: https://github.com/plastic-labs/honcho
- Python SDK: https://github.com/plastic-labs/honcho-python
- TypeScript SDK: https://github.com/plastic-labs/honcho-node
- Discord bot starter: https://github.com/plastic-labs/discord-python-starter
- Telegram bot example: https://github.com/plastic-labs/telegram-python-starter

**What Honcho Does:**
Honcho provides persistent memory and personalization for AI apps. It automatically:
- Stores conversation history across sessions
- Learns facts about users from conversations
- Builds user representations for personalized responses
- Manages multi-user sessions with theory of mind
- Provides context injection for any LLM

**Architecture Overview:**
- Core primitives: Workspaces contain Peers (users/agents) and Sessions (conversations)
- Peers can observe other peers in sessions (configurable with observe_me_observe_others)
- Background deriver processes messages to extract facts and update representations
- Dialectic API provides personalized responses based on learned context
- Supports any LLM (OpenAI, Anthropic, open source)
- Can use demo server or self-host

Please assess the resources above and ask me relevant questions to help build a well-structured application using Honcho. Consider asking about:
- What I'm trying to build
- My technical preferences and stack
- Whether I want to use the demo server or self-host
- My experience level with the technologies involved
- Specific features I need (multi-user, voice, web UI, etc.)

Once you understand my needs, help me create a working implementation with proper memory persistence.
```


# Managed Honcho Platform
Source: https://docs.honcho.dev/v2/documentation/reference/platform

Build socially intelligent agents without worrying about infrastructure

<Card title="Sign up to start using Honcho!" icon="rocket" href="https://app.honcho.dev">
  Start using the platform to manage Honcho instances for your workspace or app.
</Card>

The quickest way to begin using Honcho in production is with the
[Honcho Cloud Platform](https://app.honcho.dev). Sign up, generate an API key,
and start building with Honcho.

## 1. Go to [app.honcho.dev](https://app.honcho.dev)

Create an account to start using Honcho. If a teammate already uses Honcho, ask
them to invite you to their organization. Otherwise, you'll see a banner
prompting you to create a new one.

<Frame>
  <img src="https://mintcdn.com/plasticlabs/lVyHfvNDd8wveJyM/images/app-screenshots/welcome-to-honcho.png?maxW=970&auto=format&n=lVyHfvNDd8wveJyM&q=85&s=e2a7ee11934b4ece986997cf123945d5" alt="Honcho Platform Dashboard" width="400" height="267" loading="lazy" decoding="async" fetchpriority="low" width="970" height="1228" data-path="images/app-screenshots/welcome-to-honcho.png" srcset="https://mintcdn.com/plasticlabs/lVyHfvNDd8wveJyM/images/app-screenshots/welcome-to-honcho.png?w=280&maxW=970&auto=format&n=lVyHfvNDd8wveJyM&q=85&s=69a57a2447b60778dc975f4ed4bb8a1a 280w, https://mintcdn.com/plasticlabs/lVyHfvNDd8wveJyM/images/app-screenshots/welcome-to-honcho.png?w=560&maxW=970&auto=format&n=lVyHfvNDd8wveJyM&q=85&s=01d7e8919387b27de2fab9630a977cb7 560w, https://mintcdn.com/plasticlabs/lVyHfvNDd8wveJyM/images/app-screenshots/welcome-to-honcho.png?w=840&maxW=970&auto=format&n=lVyHfvNDd8wveJyM&q=85&s=9a38cce126bd2ccb7406dcf945f375a9 840w, https://mintcdn.com/plasticlabs/lVyHfvNDd8wveJyM/images/app-screenshots/welcome-to-honcho.png?w=1100&maxW=970&auto=format&n=lVyHfvNDd8wveJyM&q=85&s=555535a8b60ca9bf27c0ec3982290a1d 1100w, https://mintcdn.com/plasticlabs/lVyHfvNDd8wveJyM/images/app-screenshots/welcome-to-honcho.png?w=1650&maxW=970&auto=format&n=lVyHfvNDd8wveJyM&q=85&s=66303fd3e292e00829454bc41e24d8ae 1650w, https://mintcdn.com/plasticlabs/lVyHfvNDd8wveJyM/images/app-screenshots/welcome-to-honcho.png?w=2500&maxW=970&auto=format&n=lVyHfvNDd8wveJyM&q=85&s=a70d0072406c24749790c6a4beaf0807 2500w" data-optimize="true" data-opv="2" />
</Frame>

Once you've created an organization, you'll be taken to the dashboard and see
the **Get Started** page with integration guidance and links to documentation.

<img src="https://mintcdn.com/plasticlabs/lVyHfvNDd8wveJyM/images/app-screenshots/get-started-copy.png?maxW=2498&auto=format&n=lVyHfvNDd8wveJyM&q=85&s=6cb5cfe88cdcfece7360573c3a9d9732" alt="Honcho Dashboard Getting Started" width="1200" height="800" loading="lazy" decoding="async" fetchpriority="low" width="2498" height="1076" data-path="images/app-screenshots/get-started-copy.png" srcset="https://mintcdn.com/plasticlabs/lVyHfvNDd8wveJyM/images/app-screenshots/get-started-copy.png?w=280&maxW=2498&auto=format&n=lVyHfvNDd8wveJyM&q=85&s=21509a65f092e81dee6bb75bf372c2f7 280w, https://mintcdn.com/plasticlabs/lVyHfvNDd8wveJyM/images/app-screenshots/get-started-copy.png?w=560&maxW=2498&auto=format&n=lVyHfvNDd8wveJyM&q=85&s=399fd03e9cea00fbd0eb57346db2047b 560w, https://mintcdn.com/plasticlabs/lVyHfvNDd8wveJyM/images/app-screenshots/get-started-copy.png?w=840&maxW=2498&auto=format&n=lVyHfvNDd8wveJyM&q=85&s=d5574f24709f413b05f0bb1619e66a5e 840w, https://mintcdn.com/plasticlabs/lVyHfvNDd8wveJyM/images/app-screenshots/get-started-copy.png?w=1100&maxW=2498&auto=format&n=lVyHfvNDd8wveJyM&q=85&s=f95a8c7a4f226a5b87334f1ffe8c724c 1100w, https://mintcdn.com/plasticlabs/lVyHfvNDd8wveJyM/images/app-screenshots/get-started-copy.png?w=1650&maxW=2498&auto=format&n=lVyHfvNDd8wveJyM&q=85&s=ba77255298c6976808e31f990787f5a7 1650w, https://mintcdn.com/plasticlabs/lVyHfvNDd8wveJyM/images/app-screenshots/get-started-copy.png?w=2500&maxW=2498&auto=format&n=lVyHfvNDd8wveJyM&q=85&s=43a0540b5c8da7fc896d8e7db859426a 2500w" data-optimize="true" data-opv="2" />

Each organization has dedicated infrastructure running to isolate your
workloads. Until you activate a subscription under the
[Billing](https://app.honcho.dev/billing) page, the infrastructure will remain
inactive.

## 2. Activate your Honcho instance

Navigate to the [Billing](https://app.honcho.dev/billing) page to activate your subscription. Your Honcho instance provisions automatically, and you can monitor the deployment on the [Instance Status](https://app.honcho.dev/status) page until all systems show a green check mark.

<img src="https://mintcdn.com/plasticlabs/lVyHfvNDd8wveJyM/images/app-screenshots/status-page.png?maxW=1748&auto=format&n=lVyHfvNDd8wveJyM&q=85&s=a7a891ef94d118283513ee9bca73fed9" alt="Instance Status Page" width="1200" height="800" loading="lazy" decoding="async" fetchpriority="low" width="1748" height="992" data-path="images/app-screenshots/status-page.png" srcset="https://mintcdn.com/plasticlabs/lVyHfvNDd8wveJyM/images/app-screenshots/status-page.png?w=280&maxW=1748&auto=format&n=lVyHfvNDd8wveJyM&q=85&s=eaa9aeef8f937f06992571323b1d1507 280w, https://mintcdn.com/plasticlabs/lVyHfvNDd8wveJyM/images/app-screenshots/status-page.png?w=560&maxW=1748&auto=format&n=lVyHfvNDd8wveJyM&q=85&s=075370e23d59e4c75f064f5460a53eef 560w, https://mintcdn.com/plasticlabs/lVyHfvNDd8wveJyM/images/app-screenshots/status-page.png?w=840&maxW=1748&auto=format&n=lVyHfvNDd8wveJyM&q=85&s=b3a30550ee7813ffa9b49c6a86321e0f 840w, https://mintcdn.com/plasticlabs/lVyHfvNDd8wveJyM/images/app-screenshots/status-page.png?w=1100&maxW=1748&auto=format&n=lVyHfvNDd8wveJyM&q=85&s=30b94822413992871cbc07be3c9aa764 1100w, https://mintcdn.com/plasticlabs/lVyHfvNDd8wveJyM/images/app-screenshots/status-page.png?w=1650&maxW=1748&auto=format&n=lVyHfvNDd8wveJyM&q=85&s=91eb0e039fff15764a9afa94bf25c21f 1650w, https://mintcdn.com/plasticlabs/lVyHfvNDd8wveJyM/images/app-screenshots/status-page.png?w=2500&maxW=1748&auto=format&n=lVyHfvNDd8wveJyM&q=85&s=c14557284112fd21b580c2a445360dd6 2500w" data-optimize="true" data-opv="2" />

You can also upgrade Honcho when new versions are made available directly from the status page.

<img src="https://mintcdn.com/plasticlabs/lVyHfvNDd8wveJyM/images/app-screenshots/upgrade-honcho.png?maxW=1330&auto=format&n=lVyHfvNDd8wveJyM&q=85&s=afda11b7a3566079e9adb1251b04d057" alt="Upgrade Honcho" width="1200" height="800" loading="lazy" decoding="async" fetchpriority="low" width="1330" height="545" data-path="images/app-screenshots/upgrade-honcho.png" srcset="https://mintcdn.com/plasticlabs/lVyHfvNDd8wveJyM/images/app-screenshots/upgrade-honcho.png?w=280&maxW=1330&auto=format&n=lVyHfvNDd8wveJyM&q=85&s=d64700b06379e98d710f0a34ba7ed7f8 280w, https://mintcdn.com/plasticlabs/lVyHfvNDd8wveJyM/images/app-screenshots/upgrade-honcho.png?w=560&maxW=1330&auto=format&n=lVyHfvNDd8wveJyM&q=85&s=989aa242bdc5e6a63d3dae4eccce3583 560w, https://mintcdn.com/plasticlabs/lVyHfvNDd8wveJyM/images/app-screenshots/upgrade-honcho.png?w=840&maxW=1330&auto=format&n=lVyHfvNDd8wveJyM&q=85&s=863e9fa4d5c1587b4af606b80948e1ba 840w, https://mintcdn.com/plasticlabs/lVyHfvNDd8wveJyM/images/app-screenshots/upgrade-honcho.png?w=1100&maxW=1330&auto=format&n=lVyHfvNDd8wveJyM&q=85&s=ce48b227b77d3a7ff6191f479dd63ea3 1100w, https://mintcdn.com/plasticlabs/lVyHfvNDd8wveJyM/images/app-screenshots/upgrade-honcho.png?w=1650&maxW=1330&auto=format&n=lVyHfvNDd8wveJyM&q=85&s=be3392069a51e6dffd951530cd0dcf07 1650w, https://mintcdn.com/plasticlabs/lVyHfvNDd8wveJyM/images/app-screenshots/upgrade-honcho.png?w=2500&maxW=1330&auto=format&n=lVyHfvNDd8wveJyM&q=85&s=6b1386066a5a1c15e7c040ca14f63a58 2500w" data-optimize="true" data-opv="2" />

The **Performance** page provides comprehensive monitoring with usage metrics, health analytics, API response times, and endpoint usage across Honcho.

<img src="https://mintcdn.com/plasticlabs/lVyHfvNDd8wveJyM/images/app-screenshots/performance-analytics.png?maxW=2964&auto=format&n=lVyHfvNDd8wveJyM&q=85&s=b3fd5808404b7bad4dd6e6669535b44f" alt="Performance Analytics Dashboard" width="1200" height="800" loading="lazy" decoding="async" fetchpriority="low" width="2964" height="1424" data-path="images/app-screenshots/performance-analytics.png" srcset="https://mintcdn.com/plasticlabs/lVyHfvNDd8wveJyM/images/app-screenshots/performance-analytics.png?w=280&maxW=2964&auto=format&n=lVyHfvNDd8wveJyM&q=85&s=5124d9fc45c5aec15b627090492c08cd 280w, https://mintcdn.com/plasticlabs/lVyHfvNDd8wveJyM/images/app-screenshots/performance-analytics.png?w=560&maxW=2964&auto=format&n=lVyHfvNDd8wveJyM&q=85&s=3bbd10f46aaa2e0efcba40659bf96108 560w, https://mintcdn.com/plasticlabs/lVyHfvNDd8wveJyM/images/app-screenshots/performance-analytics.png?w=840&maxW=2964&auto=format&n=lVyHfvNDd8wveJyM&q=85&s=dec2a4de906e89ab31df4c31283224c5 840w, https://mintcdn.com/plasticlabs/lVyHfvNDd8wveJyM/images/app-screenshots/performance-analytics.png?w=1100&maxW=2964&auto=format&n=lVyHfvNDd8wveJyM&q=85&s=7e6507cb4e3e8746e1a5dd8cc15f6bd6 1100w, https://mintcdn.com/plasticlabs/lVyHfvNDd8wveJyM/images/app-screenshots/performance-analytics.png?w=1650&maxW=2964&auto=format&n=lVyHfvNDd8wveJyM&q=85&s=17831510379e052e56da2286d91a9e35 1650w, https://mintcdn.com/plasticlabs/lVyHfvNDd8wveJyM/images/app-screenshots/performance-analytics.png?w=2500&maxW=2964&auto=format&n=lVyHfvNDd8wveJyM&q=85&s=068c6897740734fdf46796a7318db027 2500w" data-optimize="true" data-opv="2" />

## 3. Manage API Keys

The [API Keys](https://app.honcho.dev/api-keys) page allows you to create and manage authentication tokens for different environments. You can create admin-level keys with full instance access or scope keys to specific `Workspaces`, `Peers`, or `Sessions`.

<img src="https://mintcdn.com/plasticlabs/lVyHfvNDd8wveJyM/images/app-screenshots/api-keys.png?maxW=2532&auto=format&n=lVyHfvNDd8wveJyM&q=85&s=af6182cccb51a3e6b873c49cc77103e2" alt="API Key Management Dashboard" width="1200" height="800" loading="lazy" decoding="async" fetchpriority="low" width="2532" height="1094" data-path="images/app-screenshots/api-keys.png" srcset="https://mintcdn.com/plasticlabs/lVyHfvNDd8wveJyM/images/app-screenshots/api-keys.png?w=280&maxW=2532&auto=format&n=lVyHfvNDd8wveJyM&q=85&s=aef31b4d3107a067ab683f92705d982a 280w, https://mintcdn.com/plasticlabs/lVyHfvNDd8wveJyM/images/app-screenshots/api-keys.png?w=560&maxW=2532&auto=format&n=lVyHfvNDd8wveJyM&q=85&s=616e8d0ff236bdeca7ff7238f21ddb98 560w, https://mintcdn.com/plasticlabs/lVyHfvNDd8wveJyM/images/app-screenshots/api-keys.png?w=840&maxW=2532&auto=format&n=lVyHfvNDd8wveJyM&q=85&s=3d5d0899fcb5c696b43dda3b388313eb 840w, https://mintcdn.com/plasticlabs/lVyHfvNDd8wveJyM/images/app-screenshots/api-keys.png?w=1100&maxW=2532&auto=format&n=lVyHfvNDd8wveJyM&q=85&s=d346f6c53c403cbee42ba55845ceca89 1100w, https://mintcdn.com/plasticlabs/lVyHfvNDd8wveJyM/images/app-screenshots/api-keys.png?w=1650&maxW=2532&auto=format&n=lVyHfvNDd8wveJyM&q=85&s=f0f4be4b4b96ad33432b1069e052a7b3 1650w, https://mintcdn.com/plasticlabs/lVyHfvNDd8wveJyM/images/app-screenshots/api-keys.png?w=2500&maxW=2532&auto=format&n=lVyHfvNDd8wveJyM&q=85&s=ed4fcd0e8dcc57e5d8633bfe07bdfb3d 2500w" data-optimize="true" data-opv="2" />

## 4. Test with API Playground

The [API Playground](https://app.honcho.dev/playground) provides a Postman-like interface to test queries, explore endpoints, and validate your integration. Authenticate with an API key and send requests directly to your Honcho instance with real-time responses and full request/response logging.

<img src="https://mintcdn.com/plasticlabs/lVyHfvNDd8wveJyM/images/app-screenshots/api-playground.png?maxW=2520&auto=format&n=lVyHfvNDd8wveJyM&q=85&s=baecc99a5120cc5753b1f182c783e90b" alt="API Playground Interface" width="1200" height="800" loading="lazy" decoding="async" fetchpriority="low" width="2520" height="1086" data-path="images/app-screenshots/api-playground.png" srcset="https://mintcdn.com/plasticlabs/lVyHfvNDd8wveJyM/images/app-screenshots/api-playground.png?w=280&maxW=2520&auto=format&n=lVyHfvNDd8wveJyM&q=85&s=b49a7dd705d4cf1157704972f1948ef1 280w, https://mintcdn.com/plasticlabs/lVyHfvNDd8wveJyM/images/app-screenshots/api-playground.png?w=560&maxW=2520&auto=format&n=lVyHfvNDd8wveJyM&q=85&s=1a85d240494d830f6eb48dd004262218 560w, https://mintcdn.com/plasticlabs/lVyHfvNDd8wveJyM/images/app-screenshots/api-playground.png?w=840&maxW=2520&auto=format&n=lVyHfvNDd8wveJyM&q=85&s=a28a69eb96e93f0eb1f2663bff481849 840w, https://mintcdn.com/plasticlabs/lVyHfvNDd8wveJyM/images/app-screenshots/api-playground.png?w=1100&maxW=2520&auto=format&n=lVyHfvNDd8wveJyM&q=85&s=99f5485626fff1471eab953a408ed5d7 1100w, https://mintcdn.com/plasticlabs/lVyHfvNDd8wveJyM/images/app-screenshots/api-playground.png?w=1650&maxW=2520&auto=format&n=lVyHfvNDd8wveJyM&q=85&s=7f6688c22e1fef6ad9b12dc679cf1222 1650w, https://mintcdn.com/plasticlabs/lVyHfvNDd8wveJyM/images/app-screenshots/api-playground.png?w=2500&maxW=2520&auto=format&n=lVyHfvNDd8wveJyM&q=85&s=56e18981f9d73a83038631eab479c333 2500w" data-optimize="true" data-opv="2" />

## 5. Workspaces

The [Explore](https://app.honcho.dev/explore) page provides comprehensive `Workspace` management where you can create workspaces and begin exploring the platform. Each `Workspace` serves as a container for organizing your Honcho data.

<img src="https://mintcdn.com/plasticlabs/lVyHfvNDd8wveJyM/images/app-screenshots/explore-honcho.png?maxW=2098&auto=format&n=lVyHfvNDd8wveJyM&q=85&s=1ee5d92ebeb64af3bebe3d7613b65db6" alt="Workspace Table" width="1200" height="800" loading="lazy" decoding="async" fetchpriority="low" width="2098" height="986" data-path="images/app-screenshots/explore-honcho.png" srcset="https://mintcdn.com/plasticlabs/lVyHfvNDd8wveJyM/images/app-screenshots/explore-honcho.png?w=280&maxW=2098&auto=format&n=lVyHfvNDd8wveJyM&q=85&s=d514bb61ac3df1d4fb3ce4c70ad31266 280w, https://mintcdn.com/plasticlabs/lVyHfvNDd8wveJyM/images/app-screenshots/explore-honcho.png?w=560&maxW=2098&auto=format&n=lVyHfvNDd8wveJyM&q=85&s=f86391a93f2b94c8f27c51ac2af64f6e 560w, https://mintcdn.com/plasticlabs/lVyHfvNDd8wveJyM/images/app-screenshots/explore-honcho.png?w=840&maxW=2098&auto=format&n=lVyHfvNDd8wveJyM&q=85&s=a6912e28a1f60901a9b8e7069753db06 840w, https://mintcdn.com/plasticlabs/lVyHfvNDd8wveJyM/images/app-screenshots/explore-honcho.png?w=1100&maxW=2098&auto=format&n=lVyHfvNDd8wveJyM&q=85&s=957b70d240bb2ed07805e2ec9edc3663 1100w, https://mintcdn.com/plasticlabs/lVyHfvNDd8wveJyM/images/app-screenshots/explore-honcho.png?w=1650&maxW=2098&auto=format&n=lVyHfvNDd8wveJyM&q=85&s=9d28dcf0203b2d76e65062ea406961ac 1650w, https://mintcdn.com/plasticlabs/lVyHfvNDd8wveJyM/images/app-screenshots/explore-honcho.png?w=2500&maxW=2098&auto=format&n=lVyHfvNDd8wveJyM&q=85&s=6208f04ad6c9ea0ad9749a3903a15fbf 2500w" data-optimize="true" data-opv="2" />

Click into any workspace to access a general overview of `Peers` and `Sessions`. Here you can quickly create `Peers`, `Sessions`, and add multiple `Peers` to any `Session`. Edit the metadata and configuration for a `Workspace` with the Edit Config button. Click into any entity to navigate to their respective utilities pages or click the expand icon to view Workspace-wide `Peers` and `Sessions` data tables with more details.

<img src="https://mintcdn.com/plasticlabs/lVyHfvNDd8wveJyM/images/app-screenshots/workspace-dash.png?maxW=2304&auto=format&n=lVyHfvNDd8wveJyM&q=85&s=e8fd35e6cf16242da75819d0b315c18a" alt="Workspace Dashboard Overview" width="1200" height="800" loading="lazy" decoding="async" fetchpriority="low" width="2304" height="1134" data-path="images/app-screenshots/workspace-dash.png" srcset="https://mintcdn.com/plasticlabs/lVyHfvNDd8wveJyM/images/app-screenshots/workspace-dash.png?w=280&maxW=2304&auto=format&n=lVyHfvNDd8wveJyM&q=85&s=7380e61c22ae8cb70ed82aafe4be65f8 280w, https://mintcdn.com/plasticlabs/lVyHfvNDd8wveJyM/images/app-screenshots/workspace-dash.png?w=560&maxW=2304&auto=format&n=lVyHfvNDd8wveJyM&q=85&s=30c80ef46e7788a9408ac3afacf1f17a 560w, https://mintcdn.com/plasticlabs/lVyHfvNDd8wveJyM/images/app-screenshots/workspace-dash.png?w=840&maxW=2304&auto=format&n=lVyHfvNDd8wveJyM&q=85&s=2343f6552be9aa93ff0babbe5251d3f4 840w, https://mintcdn.com/plasticlabs/lVyHfvNDd8wveJyM/images/app-screenshots/workspace-dash.png?w=1100&maxW=2304&auto=format&n=lVyHfvNDd8wveJyM&q=85&s=cee2cf3f77914a503f939bccf7cfa332 1100w, https://mintcdn.com/plasticlabs/lVyHfvNDd8wveJyM/images/app-screenshots/workspace-dash.png?w=1650&maxW=2304&auto=format&n=lVyHfvNDd8wveJyM&q=85&s=adb261e13da06d93456a9b81cc231f35 1650w, https://mintcdn.com/plasticlabs/lVyHfvNDd8wveJyM/images/app-screenshots/workspace-dash.png?w=2500&maxW=2304&auto=format&n=lVyHfvNDd8wveJyM&q=85&s=5ec09db6ef494568acb81d9079118bd5 2500w" data-optimize="true" data-opv="2" />

## 6. Peer Dashboard & Utilities

Expand the `Peers` list from the `Workspace` dashboard to see a detailed view of `Peers`.

<img src="https://mintcdn.com/plasticlabs/lVyHfvNDd8wveJyM/images/app-screenshots/peer-dash.png?maxW=2296&auto=format&n=lVyHfvNDd8wveJyM&q=85&s=a4bd8e68825319b681709adbede435d5" alt="Peer Dashboard" width="1200" height="800" loading="lazy" decoding="async" fetchpriority="low" width="2296" height="988" data-path="images/app-screenshots/peer-dash.png" srcset="https://mintcdn.com/plasticlabs/lVyHfvNDd8wveJyM/images/app-screenshots/peer-dash.png?w=280&maxW=2296&auto=format&n=lVyHfvNDd8wveJyM&q=85&s=f720d6eda86e4336dfa384416219a272 280w, https://mintcdn.com/plasticlabs/lVyHfvNDd8wveJyM/images/app-screenshots/peer-dash.png?w=560&maxW=2296&auto=format&n=lVyHfvNDd8wveJyM&q=85&s=395019cded5eb41f45d51de1a773cfc0 560w, https://mintcdn.com/plasticlabs/lVyHfvNDd8wveJyM/images/app-screenshots/peer-dash.png?w=840&maxW=2296&auto=format&n=lVyHfvNDd8wveJyM&q=85&s=ebf28d939e6ed5d52c0f81cb85779c55 840w, https://mintcdn.com/plasticlabs/lVyHfvNDd8wveJyM/images/app-screenshots/peer-dash.png?w=1100&maxW=2296&auto=format&n=lVyHfvNDd8wveJyM&q=85&s=0cd87d07286d8297819e0a367455a8a5 1100w, https://mintcdn.com/plasticlabs/lVyHfvNDd8wveJyM/images/app-screenshots/peer-dash.png?w=1650&maxW=2296&auto=format&n=lVyHfvNDd8wveJyM&q=85&s=1ab9bcb90b3f7cc10d81d1d3297a15b1 1650w, https://mintcdn.com/plasticlabs/lVyHfvNDd8wveJyM/images/app-screenshots/peer-dash.png?w=2500&maxW=2296&auto=format&n=lVyHfvNDd8wveJyM&q=85&s=df2b42fed7c3c8bf4283e8cad49723cf 2500w" data-optimize="true" data-opv="2" />

Click into any peer to navigate to their respective utilities page. Next to the `Peer` name you can edit the [Global Peer Configuration](/v2/documentation/core-concepts/configuration), and in the tabs below, explore all utilities for the `Peer`.

<img src="https://mintcdn.com/plasticlabs/lVyHfvNDd8wveJyM/images/app-screenshots/peer-utilities.png?maxW=1952&auto=format&n=lVyHfvNDd8wveJyM&q=85&s=00e2cdd6b291eb6041b80e67842fb686" alt="Peer Management Dashboard" width="1200" height="800" loading="lazy" decoding="async" fetchpriority="low" width="1952" height="1118" data-path="images/app-screenshots/peer-utilities.png" srcset="https://mintcdn.com/plasticlabs/lVyHfvNDd8wveJyM/images/app-screenshots/peer-utilities.png?w=280&maxW=1952&auto=format&n=lVyHfvNDd8wveJyM&q=85&s=bc788cf6a6a9c5d9c9e6d259bd43443a 280w, https://mintcdn.com/plasticlabs/lVyHfvNDd8wveJyM/images/app-screenshots/peer-utilities.png?w=560&maxW=1952&auto=format&n=lVyHfvNDd8wveJyM&q=85&s=d653492e26c6fb240c73c375c359e26a 560w, https://mintcdn.com/plasticlabs/lVyHfvNDd8wveJyM/images/app-screenshots/peer-utilities.png?w=840&maxW=1952&auto=format&n=lVyHfvNDd8wveJyM&q=85&s=c477934473b31af271d6f0b62344962d 840w, https://mintcdn.com/plasticlabs/lVyHfvNDd8wveJyM/images/app-screenshots/peer-utilities.png?w=1100&maxW=1952&auto=format&n=lVyHfvNDd8wveJyM&q=85&s=fd5e57b2c4a3aa050644d4777f7d60ff 1100w, https://mintcdn.com/plasticlabs/lVyHfvNDd8wveJyM/images/app-screenshots/peer-utilities.png?w=1650&maxW=1952&auto=format&n=lVyHfvNDd8wveJyM&q=85&s=9ac4ff82e277277d4cfe3738ba29e4d6 1650w, https://mintcdn.com/plasticlabs/lVyHfvNDd8wveJyM/images/app-screenshots/peer-utilities.png?w=2500&maxW=1952&auto=format&n=lVyHfvNDd8wveJyM&q=85&s=a9c3af02a2f06cd9671ed16532371113 2500w" data-optimize="true" data-opv="2" />

Utilities include:

* **Message search** across all sessions for a `Peer`
* **Dialectic Chat** to query `Peer` representations globally or session-scoped (results vary dependant on the `Peer`'s configuration)

<img src="https://mintcdn.com/plasticlabs/lVyHfvNDd8wveJyM/images/app-screenshots/chat-endpoint.png?maxW=2774&auto=format&n=lVyHfvNDd8wveJyM&q=85&s=7c60b0da40e7c0cff3860d275f1c40b7" alt="Chat Endpoint" width="1200" height="800" loading="lazy" decoding="async" fetchpriority="low" width="2774" height="1550" data-path="images/app-screenshots/chat-endpoint.png" srcset="https://mintcdn.com/plasticlabs/lVyHfvNDd8wveJyM/images/app-screenshots/chat-endpoint.png?w=280&maxW=2774&auto=format&n=lVyHfvNDd8wveJyM&q=85&s=d85679c8cd4e3fb20646891e789133f0 280w, https://mintcdn.com/plasticlabs/lVyHfvNDd8wveJyM/images/app-screenshots/chat-endpoint.png?w=560&maxW=2774&auto=format&n=lVyHfvNDd8wveJyM&q=85&s=aaed3e39eadd6d340f1b924fb8a42c8b 560w, https://mintcdn.com/plasticlabs/lVyHfvNDd8wveJyM/images/app-screenshots/chat-endpoint.png?w=840&maxW=2774&auto=format&n=lVyHfvNDd8wveJyM&q=85&s=1cf131417c44f10dd43239be24d80c55 840w, https://mintcdn.com/plasticlabs/lVyHfvNDd8wveJyM/images/app-screenshots/chat-endpoint.png?w=1100&maxW=2774&auto=format&n=lVyHfvNDd8wveJyM&q=85&s=630aec5d9054d164f7fabe67202344a6 1100w, https://mintcdn.com/plasticlabs/lVyHfvNDd8wveJyM/images/app-screenshots/chat-endpoint.png?w=1650&maxW=2774&auto=format&n=lVyHfvNDd8wveJyM&q=85&s=a7b198dd70e03e822f19538509b62cfa 1650w, https://mintcdn.com/plasticlabs/lVyHfvNDd8wveJyM/images/app-screenshots/chat-endpoint.png?w=2500&maxW=2774&auto=format&n=lVyHfvNDd8wveJyM&q=85&s=4826d02e8d08f8ac16eeb872f044cad6 2500w" data-optimize="true" data-opv="2" />

* **Session logs** view which `Sessions` the `Peer` is active
* **Peer configuration and metadata management** including [Session-Peer Configuration](/v2/documentation/core-concepts/configuration#session-peer-configuration)

<img src="https://mintcdn.com/plasticlabs/lVyHfvNDd8wveJyM/images/app-screenshots/peer-utilities.png?maxW=1952&auto=format&n=lVyHfvNDd8wveJyM&q=85&s=00e2cdd6b291eb6041b80e67842fb686" alt="Peer Management Dashboard" width="1200" height="800" loading="lazy" decoding="async" fetchpriority="low" width="1952" height="1118" data-path="images/app-screenshots/peer-utilities.png" srcset="https://mintcdn.com/plasticlabs/lVyHfvNDd8wveJyM/images/app-screenshots/peer-utilities.png?w=280&maxW=1952&auto=format&n=lVyHfvNDd8wveJyM&q=85&s=bc788cf6a6a9c5d9c9e6d259bd43443a 280w, https://mintcdn.com/plasticlabs/lVyHfvNDd8wveJyM/images/app-screenshots/peer-utilities.png?w=560&maxW=1952&auto=format&n=lVyHfvNDd8wveJyM&q=85&s=d653492e26c6fb240c73c375c359e26a 560w, https://mintcdn.com/plasticlabs/lVyHfvNDd8wveJyM/images/app-screenshots/peer-utilities.png?w=840&maxW=1952&auto=format&n=lVyHfvNDd8wveJyM&q=85&s=c477934473b31af271d6f0b62344962d 840w, https://mintcdn.com/plasticlabs/lVyHfvNDd8wveJyM/images/app-screenshots/peer-utilities.png?w=1100&maxW=1952&auto=format&n=lVyHfvNDd8wveJyM&q=85&s=fd5e57b2c4a3aa050644d4777f7d60ff 1100w, https://mintcdn.com/plasticlabs/lVyHfvNDd8wveJyM/images/app-screenshots/peer-utilities.png?w=1650&maxW=1952&auto=format&n=lVyHfvNDd8wveJyM&q=85&s=9ac4ff82e277277d4cfe3738ba29e4d6 1650w, https://mintcdn.com/plasticlabs/lVyHfvNDd8wveJyM/images/app-screenshots/peer-utilities.png?w=2500&maxW=1952&auto=format&n=lVyHfvNDd8wveJyM&q=85&s=a9c3af02a2f06cd9671ed16532371113 2500w" data-optimize="true" data-opv="2" />

## 7. Session Dashboard & Utilities

Click into the sessions view within a workspace to see a table of all of your `Sessions` data.

<img src="https://mintcdn.com/plasticlabs/lVyHfvNDd8wveJyM/images/app-screenshots/session-dash.png?maxW=2280&auto=format&n=lVyHfvNDd8wveJyM&q=85&s=940352ff49b076e296d0b1da82507d9d" alt="Sessions Table" width="1200" height="800" loading="lazy" decoding="async" fetchpriority="low" width="2280" height="1038" data-path="images/app-screenshots/session-dash.png" srcset="https://mintcdn.com/plasticlabs/lVyHfvNDd8wveJyM/images/app-screenshots/session-dash.png?w=280&maxW=2280&auto=format&n=lVyHfvNDd8wveJyM&q=85&s=f857f128953e90e99689d7a00136f929 280w, https://mintcdn.com/plasticlabs/lVyHfvNDd8wveJyM/images/app-screenshots/session-dash.png?w=560&maxW=2280&auto=format&n=lVyHfvNDd8wveJyM&q=85&s=431fcd00a441e411de6fceb774cb93ed 560w, https://mintcdn.com/plasticlabs/lVyHfvNDd8wveJyM/images/app-screenshots/session-dash.png?w=840&maxW=2280&auto=format&n=lVyHfvNDd8wveJyM&q=85&s=fe4acda7e20a54d0179838be768beec3 840w, https://mintcdn.com/plasticlabs/lVyHfvNDd8wveJyM/images/app-screenshots/session-dash.png?w=1100&maxW=2280&auto=format&n=lVyHfvNDd8wveJyM&q=85&s=18254d34ec4509b374477aa6488e1ef8 1100w, https://mintcdn.com/plasticlabs/lVyHfvNDd8wveJyM/images/app-screenshots/session-dash.png?w=1650&maxW=2280&auto=format&n=lVyHfvNDd8wveJyM&q=85&s=2a8d762e35ce78e6d3fddb706a0d7384 1650w, https://mintcdn.com/plasticlabs/lVyHfvNDd8wveJyM/images/app-screenshots/session-dash.png?w=2500&maxW=2280&auto=format&n=lVyHfvNDd8wveJyM&q=85&s=0ad02c67c20d1b31573d07567c4cc0ff 2500w" data-optimize="true" data-opv="2" />

Click into a `Session` to open its utilities page.

<img src="https://mintcdn.com/plasticlabs/lVyHfvNDd8wveJyM/images/app-screenshots/session-utilities.png?maxW=2518&auto=format&n=lVyHfvNDd8wveJyM&q=85&s=ec23c922716eca5ad81a56859f319c76" alt="Session Utilities" width="1200" height="800" loading="lazy" decoding="async" fetchpriority="low" width="2518" height="1044" data-path="images/app-screenshots/session-utilities.png" srcset="https://mintcdn.com/plasticlabs/lVyHfvNDd8wveJyM/images/app-screenshots/session-utilities.png?w=280&maxW=2518&auto=format&n=lVyHfvNDd8wveJyM&q=85&s=6c02a7525acf2ea916fb1d7c50459cb0 280w, https://mintcdn.com/plasticlabs/lVyHfvNDd8wveJyM/images/app-screenshots/session-utilities.png?w=560&maxW=2518&auto=format&n=lVyHfvNDd8wveJyM&q=85&s=0b9396acba2974172f571db582a88edd 560w, https://mintcdn.com/plasticlabs/lVyHfvNDd8wveJyM/images/app-screenshots/session-utilities.png?w=840&maxW=2518&auto=format&n=lVyHfvNDd8wveJyM&q=85&s=b3c94de72e28f38e81b8a406333df965 840w, https://mintcdn.com/plasticlabs/lVyHfvNDd8wveJyM/images/app-screenshots/session-utilities.png?w=1100&maxW=2518&auto=format&n=lVyHfvNDd8wveJyM&q=85&s=2da3c15b038f28539d833df404db3cff 1100w, https://mintcdn.com/plasticlabs/lVyHfvNDd8wveJyM/images/app-screenshots/session-utilities.png?w=1650&maxW=2518&auto=format&n=lVyHfvNDd8wveJyM&q=85&s=c05583a887eba25a70540d79e03972ee 1650w, https://mintcdn.com/plasticlabs/lVyHfvNDd8wveJyM/images/app-screenshots/session-utilities.png?w=2500&maxW=2518&auto=format&n=lVyHfvNDd8wveJyM&q=85&s=09007c8fcddbd5eaa93a66a0e74a68a4 2500w" data-optimize="true" data-opv="2" />

Here you can:

* **View and add Messages** within the `Session`; filter messages by `Peer`
* **Advanced search** across `Session` messages
* **Peer management** for adding/removing `Peers` and editing a `Peer`'s Session-level configuration
* **Get Context** to generate LLM-ready context with customizable token limits

<img src="https://mintcdn.com/plasticlabs/lVyHfvNDd8wveJyM/images/app-screenshots/get-context.png?maxW=2074&auto=format&n=lVyHfvNDd8wveJyM&q=85&s=ee868faeab0348ee190bcde1baa59d32" alt="Get Context" width="1200" height="800" loading="lazy" decoding="async" fetchpriority="low" width="2074" height="970" data-path="images/app-screenshots/get-context.png" srcset="https://mintcdn.com/plasticlabs/lVyHfvNDd8wveJyM/images/app-screenshots/get-context.png?w=280&maxW=2074&auto=format&n=lVyHfvNDd8wveJyM&q=85&s=9a12094f8e43d5321873c7c0ca890727 280w, https://mintcdn.com/plasticlabs/lVyHfvNDd8wveJyM/images/app-screenshots/get-context.png?w=560&maxW=2074&auto=format&n=lVyHfvNDd8wveJyM&q=85&s=fee5e99d65358db3552d879b7dfd4a3f 560w, https://mintcdn.com/plasticlabs/lVyHfvNDd8wveJyM/images/app-screenshots/get-context.png?w=840&maxW=2074&auto=format&n=lVyHfvNDd8wveJyM&q=85&s=8702132b54b24d00274c640d9ae777af 840w, https://mintcdn.com/plasticlabs/lVyHfvNDd8wveJyM/images/app-screenshots/get-context.png?w=1100&maxW=2074&auto=format&n=lVyHfvNDd8wveJyM&q=85&s=1a40c093c6541f3ee9f9d30414980d86 1100w, https://mintcdn.com/plasticlabs/lVyHfvNDd8wveJyM/images/app-screenshots/get-context.png?w=1650&maxW=2074&auto=format&n=lVyHfvNDd8wveJyM&q=85&s=a45b820c4087d51040063c68ccd292fc 1650w, https://mintcdn.com/plasticlabs/lVyHfvNDd8wveJyM/images/app-screenshots/get-context.png?w=2500&maxW=2074&auto=format&n=lVyHfvNDd8wveJyM&q=85&s=88a6311370d04069c9a826b47172e629 2500w" data-optimize="true" data-opv="2" />

## 8. Webhooks Integration

The [Webhooks](https://app.honcho.dev/webhooks) page enables Webhook creation and management.

<img src="https://mintcdn.com/plasticlabs/lVyHfvNDd8wveJyM/images/app-screenshots/webhooks-page.png?maxW=2190&auto=format&n=lVyHfvNDd8wveJyM&q=85&s=38e06c6881723344c916ed17add1533b" alt="Webhooks Dashboard" width="1200" height="800" loading="lazy" decoding="async" fetchpriority="low" width="2190" height="1002" data-path="images/app-screenshots/webhooks-page.png" srcset="https://mintcdn.com/plasticlabs/lVyHfvNDd8wveJyM/images/app-screenshots/webhooks-page.png?w=280&maxW=2190&auto=format&n=lVyHfvNDd8wveJyM&q=85&s=9ddeca9780189991dab65a004ea400a9 280w, https://mintcdn.com/plasticlabs/lVyHfvNDd8wveJyM/images/app-screenshots/webhooks-page.png?w=560&maxW=2190&auto=format&n=lVyHfvNDd8wveJyM&q=85&s=7b04c86fb532f2dce5451a959e9be63d 560w, https://mintcdn.com/plasticlabs/lVyHfvNDd8wveJyM/images/app-screenshots/webhooks-page.png?w=840&maxW=2190&auto=format&n=lVyHfvNDd8wveJyM&q=85&s=a7cc4bfd79fa77e4a78adc50850e9672 840w, https://mintcdn.com/plasticlabs/lVyHfvNDd8wveJyM/images/app-screenshots/webhooks-page.png?w=1100&maxW=2190&auto=format&n=lVyHfvNDd8wveJyM&q=85&s=f952cf32f43ca6abb70f6eec26a724e9 1100w, https://mintcdn.com/plasticlabs/lVyHfvNDd8wveJyM/images/app-screenshots/webhooks-page.png?w=1650&maxW=2190&auto=format&n=lVyHfvNDd8wveJyM&q=85&s=e9b1f736fd9bbbb5697c6e2310e9e583 1650w, https://mintcdn.com/plasticlabs/lVyHfvNDd8wveJyM/images/app-screenshots/webhooks-page.png?w=2500&maxW=2190&auto=format&n=lVyHfvNDd8wveJyM&q=85&s=48e07b8a373de83320ac449a7612874e 2500w" data-optimize="true" data-opv="2" />

## 9. Organization Member Access

The [Members](https://app.honcho.dev/members) page provides organization administration to manage your team's access to Honcho with the ability to grant admin permissions.

<img src="https://mintcdn.com/plasticlabs/lVyHfvNDd8wveJyM/images/app-screenshots/members-dashboard.png?maxW=1614&auto=format&n=lVyHfvNDd8wveJyM&q=85&s=4a11d03490c3f171edbd9f32b111bd9f" alt="Members Dashboard" width="1200" height="800" loading="lazy" decoding="async" fetchpriority="low" width="1614" height="285" data-path="images/app-screenshots/members-dashboard.png" srcset="https://mintcdn.com/plasticlabs/lVyHfvNDd8wveJyM/images/app-screenshots/members-dashboard.png?w=280&maxW=1614&auto=format&n=lVyHfvNDd8wveJyM&q=85&s=4761b51a5447ef77de9b443a8be77eaf 280w, https://mintcdn.com/plasticlabs/lVyHfvNDd8wveJyM/images/app-screenshots/members-dashboard.png?w=560&maxW=1614&auto=format&n=lVyHfvNDd8wveJyM&q=85&s=6fd019b4e59e5310fc987a9986b375a2 560w, https://mintcdn.com/plasticlabs/lVyHfvNDd8wveJyM/images/app-screenshots/members-dashboard.png?w=840&maxW=1614&auto=format&n=lVyHfvNDd8wveJyM&q=85&s=4291ea2a1ada39657de0c4554f260388 840w, https://mintcdn.com/plasticlabs/lVyHfvNDd8wveJyM/images/app-screenshots/members-dashboard.png?w=1100&maxW=1614&auto=format&n=lVyHfvNDd8wveJyM&q=85&s=784af3f60bb10c81a815918e1c7a362f 1100w, https://mintcdn.com/plasticlabs/lVyHfvNDd8wveJyM/images/app-screenshots/members-dashboard.png?w=1650&maxW=1614&auto=format&n=lVyHfvNDd8wveJyM&q=85&s=ee24500f290cec8ecc4aeb56c8d38708 1650w, https://mintcdn.com/plasticlabs/lVyHfvNDd8wveJyM/images/app-screenshots/members-dashboard.png?w=2500&maxW=1614&auto=format&n=lVyHfvNDd8wveJyM&q=85&s=703d1e49573f95fea783d547d4295f15 2500w" data-optimize="true" data-opv="2" />

## Go Further

View the [Architecture](/v2/documentation/reference/architecture) to see how Honcho works under the hood.

Dive into our [API Reference](/v2/api-reference) to explore all available endpoints.

## Next Steps

<CardGroup cols={2}>
  <Card title="Sign up to Honcho Platform" icon="rocket" href="https://app.honcho.dev">
    Get started with managed Honcho instances
  </Card>

  <Card title="Join our Discord" icon="discord" href="http://discord.gg/plasticlabs">
    Connect with 1000+ developers building with Honcho
  </Card>

  <Card title="Contribute to Honcho" icon="code" href="/v2/contributing/guidelines">
    View our guidelines and explore the codebase
  </Card>

  <Card title="Explore Examples" icon="book" href="/v2/guides">
    See Honcho in action with real examples
  </Card>
</CardGroup>

We're excited to see what you'll build with Honcho Platform. Let's create smarter, more personalized AI experiences together!

***

*Ready to build personally aligned AI? [Get started with Honcho →](https://app.honcho.dev)*


# SDK Reference
Source: https://docs.honcho.dev/v2/documentation/reference/sdk

Complete SDK documentation and examples for Python and TypeScript

The Honcho SDKs provide ergonomic interfaces for building agentic AI applications with Honcho in Python and TypeScript/JavaScript.

## Installation

<CodeGroup>
  ```bash Python (uv)
  uv add honcho-ai
  ```

  ```bash Python (pip)
  pip install honcho-ai
  ```

  ```bash TypeScript (npm)
  npm install @honcho-ai/sdk
  ```

  ```bash TypeScript (yarn)
  yarn add @honcho-ai/sdk
  ```

  ```bash TypeScript (pnpm)
  pnpm add @honcho-ai/sdk
  ```
</CodeGroup>

## Quickstart

<Info>
  Without configuration, the SDK defaults to the demo server. For production use:

  1. Get your API key at [app.honcho.dev/api-keys](https://app.honcho.dev/api-keys)
  2. Set `environment="production"` and provide your `api_key`
</Info>

<CodeGroup>
  ```python Python
  from honcho import Honcho

  # Initialize client (using the default workspace)
  honcho = Honcho()

  # Create peers
  alice = honcho.peer("alice")
  assistant = honcho.peer("assistant")

  # Create a session for conversation
  session = honcho.session("conversation-1")

  # Add messages to conversation
  session.add_messages([
      alice.message("What's the weather like today?"),
      assistant.message("It's sunny and 75°F outside!")
  ])

  # Query peer representations in natural language
  response = alice.chat("What did the assistant tell this user about the weather?")

  # Get conversation context for LLM completions
  context = session.get_context()
  openai_messages = context.to_openai(assistant=assistant)
  ```

  ```typescript TypeScript
  import { Honcho } from "@honcho-ai/sdk";

  // Initialize client (using the default workspace)
  const honcho = new Honcho({});

  // Create peers
  const alice = await honcho.peer("alice");
  const assistant = await honcho.peer("assistant");

  // Create a session for conversation
  const session = await honcho.session("conversation-1");

  // Add messages to conversation
  await session.addMessages([
    alice.message("What's the weather like today?"),
    assistant.message("It's sunny and 75°F outside!")
  ]);

  // Query peer representations in natural language
  const response = await alice.chat("What did the assistant tell this user about the weather?");

  // Get conversation context for LLM completions
  const context = await session.getContext();
  const openaiMessages = context.toOpenAI(assistant);
  ```
</CodeGroup>

## Core Concepts

### Peers and Representations

<Info>
  **Representations** are how Honcho models what peers know. Each peer has a **global representation** (everything they know across all sessions) and **local representations** (what other specific peers know about them, scoped by session or globally).
</Info>

<CodeGroup>
  ```python Python
  # Query alice's global knowledge
  response = alice.chat("What does the user know about weather?")

  # Query what alice knows about the assistant (local representation)
  response = alice.chat("What does the user know about the assistant?", target=assistant)

  # Query scoped to a specific session
  response = alice.chat("What happened in our conversation?", session_id=session.id)
  ```

  ```typescript TypeScript
  // Query alice's global knowledge
  const response = await alice.chat("What does the user know about weather?");

  // Query what alice knows about the assistant (local representation)
  const targetResponse = await alice.chat("What does the user know about the assistant?", {
    target: assistant
  });

  // Query scoped to a specific session
  const sessionResponse = await alice.chat("What happened in our conversation?", {
    sessionId: session.id
  });
  ```
</CodeGroup>

## Core Classes

### Honcho Client

The main entry point for workspace operations:

<CodeGroup>
  ```python Python
  from honcho import Honcho

  # Basic initialization (uses environment variables)
  honcho = Honcho(workspace_id="my-app-name")

  # Full configuration
  honcho = Honcho(
      workspace_id="my-app-name",
      api_key="my-api-key",
      environment="production",  # or "local", "demo"
      base_url="https://api.honcho.dev",
      timeout=30.0,
      max_retries=3
  )
  ```

  ```typescript TypeScript
  import { Honcho } from "@honcho-ai/sdk";

  // Basic initialization (uses environment variables)
  const honcho = new Honcho({
    workspaceId: "my-app-name"
  });

  // Full configuration
  const honcho = new Honcho({
    workspaceId: "my-app-name",
    apiKey: "my-api-key",
    environment: "production",  // or "local", "demo"
    baseURL: "https://api.honcho.dev",
    timeout: 30000,
    maxRetries: 3,
    defaultHeaders: { "X-Custom-Header": "value" },
    defaultQuery: { "param": "value" }
  });
  ```
</CodeGroup>

**Environment Variables:**

* `HONCHO_API_KEY` - API key for authentication
* `HONCHO_BASE_URL` - Base URL for the Honcho API
* `HONCHO_WORKSPACE_ID` - Default workspace ID

**Key Methods:**

<CodeGroup>
  ```python Python
  # Get or create a peer
  peer = honcho.peer(id)

  # Get or create a session
  session = honcho.session(id)

  # List all peers in workspace
  peers = honcho.get_peers()

  # List all sessions in workspace
  sessions = honcho.get_sessions()

  # Search across all content in workspace
  results = honcho.search(query)

  # Workspace metadata management
  metadata = honcho.get_metadata()
  honcho.set_metadata(dict)

  # Get list of all workspace IDs
  workspaces = honcho.get_workspaces()
  ```

  ```typescript TypeScript
  // Get or create a peer
  const peer = await honcho.peer(id);

  // Get or create a session
  const session = await honcho.session(id);

  // List all peers in workspace (returns Page<Peer>)
  const peers = await honcho.getPeers();

  // List all sessions in workspace (returns Page<Session>)
  const sessions = await honcho.getSessions();

  // Search across all content in workspace (returns Page<any>)
  const results = await honcho.search(query);

  // Workspace metadata management
  const metadata = await honcho.getMetadata();
  await honcho.setMetadata(metadata);

  // Get list of all workspace IDs
  const workspaces = await honcho.getWorkspaces();
  ```
</CodeGroup>

<Info>
  Peer and session creation is **lazy** - no API calls are made until you actually use the peer or session.
</Info>

### Peer

Represents an entity that can participate in conversations:

<CodeGroup>
  ```python Python
  # Create peers (lazy creation - no API call yet)
  alice = honcho.peer("alice")
  assistant = honcho.peer("assistant")

  # Create with immediate configuration
  # This will make an API call to create the peer with the custom configuration and/or metadata
  alice = honcho.peer("bob", config={"role": "user", "active": True}, metadata={"location": "NYC", "role": "developer"})

  # Peer properties
  print(f"Peer ID: {alice.id}")
  print(f"Workspace: {alice.workspace_id}")

  # Chat with peer's representations (supports streaming)
  response = alice.chat("What did I have for breakfast?")
  response = alice.chat("What do I know about Bob?", target="bob")
  response = alice.chat("What happened in session-1?", session_id="session-1")

  # Add content to a session with a peer
  session = honcho.session("session-1")
  session.add_messages([
    alice.message("I love Python programming"),
    alice.message("Today I learned about async programming"),
    alice.message("I prefer functional programming patterns")
  ])

  # Get peer's sessions
  sessions = alice.get_sessions()

  # Search peer's messages
  results = alice.search("programming")

  # Metadata management
  metadata = alice.get_metadata()
  metadata["location"] = "Paris"
  alice.set_metadata(metadata)
  ```

  ```typescript TypeScript
  // Create peers (returns Promise<Peer>)
  const alice = await honcho.peer("alice");
  const assistant = await honcho.peer("assistant");

  // Peer properties
  console.log(`Peer ID: ${alice.id}`);

  // Chat with peer's representations (supports streaming)
  const response = await alice.chat("What did I have for breakfast?");
  const targetResponse = await alice.chat("What do I know about Bob?", { target: "bob" });
  const sessionResponse = await alice.chat("What happened in session-1?", {
    sessionId: "session-1"
  });

  // Chat with streaming support
  const streamResponse = await alice.chat("Tell me a story", { stream: true });

  // Add content to a session with a peer
  const session = await honcho.session("session-1");
  await session.addMessages([
    alice.message("I love TypeScript programming"),
    alice.message("Today I learned about async programming"),
    alice.message("I prefer functional programming patterns")
  ]);

  // Get peer's sessions
  const sessions = await alice.getSessions();

  // Search peer's messages
  const results = await alice.search("programming");

  // Metadata management
  const metadata = await alice.getMetadata();
  await alice.setMetadata({
    ...metadata,
    location: "Paris"
  });
  ```
</CodeGroup>

### Session

Manages multi-party conversations:

<CodeGroup>
  ```python Python
  # Create session (like peers, lazy creation)
  session = honcho.session("conversation-1")

  # Create with immediate configuration
  # This will make an API call to create the session with the custom configuration and/or metadata
  session = honcho.session("meeting-1", config={"type": "meeting", "max_peers": 10})

  # Session properties
  print(f"Session ID: {session.id}")
  print(f"Workspace: {session.workspace_id}")

  # Peer management
  session.add_peers([alice, assistant])
  session.add_peers([(alice, SessionPeerConfig(observe_others=True))])
  session.set_peers([alice, bob, charlie])  # Replace all peers
  session.remove_peers([alice])

  # Get session peers and their configurations
  peers = session.get_peers()
  peer_config = session.get_peer_config(alice)
  session.set_peer_config(alice, SessionPeerConfig(observe_me=False))

  # Message management
  session.add_messages([
      alice.message("Hello everyone!"),
      assistant.message("Hi Alice! How can I help today?")
  ])

  # Get messages
  messages = session.get_messages()

  # Get conversation context
  context = session.get_context(summary=True, tokens=2000)

  # Search session content
  results = session.search("help")

  # Working representation queries
  global_rep = session.working_rep("alice")
  targeted_rep = session.working_rep(alice, bob)

  # Metadata management
  session.set_metadata({"topic": "product planning", "status": "active"})
  metadata = session.get_metadata()
  ```

  ```typescript TypeScript
  // Create session (returns Promise<Session>)
  const session = await honcho.session("conversation-1");

  // Session properties
  console.log(`Session ID: ${session.id}`);

  // Peer management
  await session.addPeers([alice, assistant]);
  await session.addPeers("single-peer-id");
  await session.setPeers([alice, bob, charlie]);  // Replace all peers
  await session.removePeers([alice]);
  await session.removePeers("single-peer-id");

  // Get session peers
  const peers = await session.getPeers();

  // Message management
  await session.addMessages([
    alice.message("Hello everyone!"),
    assistant.message("Hi Alice! How can I help today?")
  ]);

  // Get messages
  const messages = await session.getMessages();

  // Get conversation context
  const context = await session.getContext({ summary: true, tokens: 2000 });

  // Search session content
  const results = await session.search("help");

  // Working representation queries
  const globalRep = await session.workingRep("alice");
  const targetedRep = await session.workingRep(alice, bob);

  // Metadata management
  await session.setMetadata({
    topic: "product planning",
    status: "active"
  });
  const metadata = await session.getMetadata();
  ```
</CodeGroup>

**Session-Level Theory of Mind Configuration:**

<Info>
  **Theory of Mind** controls whether peers can form models of what other peers think. Use `observe_others=False` to prevent a peer from modeling others within a session, and `observe_me=False` to prevent others from modeling this peer within a session.
</Info>

<CodeGroup>
  ```python Python
  from honcho import SessionPeerConfig

  # Configure peer observation settings
  config = SessionPeerConfig(
      observe_others=False,  # Form theory-of-mind of other peers -- False by default
      observe_me=True        # Don't let others form theory-of-mind of me -- True by default
  )

  session.add_peers([(alice, config)])
  ```

  ```typescript TypeScript
  // Configure peer observation settings
  const config = new SessionPeerConfig({
      observeOthers: false,  // Form theory-of-mind of other peers -- False by default
      observeMe: true        // Don't let others form theory-of-mind of me -- True by default
  });

  await session.addPeers([alice, config]);
  ```
</CodeGroup>

### SessionContext

Provides formatted conversation context for LLM integration:

<CodeGroup>
  ```python Python
  # Get session context
  context = session.get_context(summary=True, tokens=1500)

  # Convert to LLM-friendly formats
  openai_messages = context.to_openai(assistant=assistant)
  anthropic_messages = context.to_anthropic(assistant=assistant)
  ```

  ```typescript TypeScript
  // Get session context
  const context = await session.getContext({ summary: true, tokens: 1500 });

  // Convert to LLM-friendly formats
  const openaiMessages = context.toOpenAI(assistant);
  const anthropicMessages = context.toAnthropic(assistant);
  ```
</CodeGroup>

The SessionContext object has the following structure:

```json
{
  "id": "string",
  "messages": [
    {
      "id": "string",
      "content": "string",
      "peer_id": "string",
      "session_id": "string",
      "workspace_id": "string",
      "metadata": {},
      "created_at": "2024-01-15T10:30:00Z",
      "token_count": 42
    }
  ],
  "summary": {
    "content": "string",
    "message_id": 123,
    "summary_type": "short|long",
    "created_at": "2024-01-15T10:30:00Z"
  }
}
```

## Advanced Usage

### Multi-Party Conversations

<CodeGroup>
  ```python Python
  # Create multiple peers
  users = [honcho.peer(f"user-{i}") for i in range(5)]
  moderator = honcho.peer("moderator")

  # Create group session
  group_chat = honcho.session("group-discussion")
  group_chat.add_peers(users + [moderator])

  # Add messages from different peers
  group_chat.add_messages([
      users[0].message("What's our agenda for today?"),
      moderator.message("We'll discuss the new feature roadmap"),
      users[1].message("I have some concerns about the timeline")
  ])

  # Query different perspectives
  user_perspective = users[0].chat("What are people's concerns?")
  moderator_view = moderator.chat("What feedback am I getting?", session_id=group_chat.id)
  ```

  ```typescript TypeScript
  // Create multiple peers
  const users = await Promise.all(
    Array.from({ length: 5 }, (_, i) => honcho.peer(`user-${i}`))
  );
  const moderator = await honcho.peer("moderator");

  // Create group session
  const groupChat = await honcho.session("group-discussion");
  await groupChat.addPeers([...users, moderator]);

  // Add messages from different peers
  await groupChat.addMessages([
    users[0].message("What's our agenda for today?"),
    moderator.message("We'll discuss the new feature roadmap"),
    users[1].message("I have some concerns about the timeline")
  ]);

  // Query different perspectives
  const userPerspective = await users[0].chat("What are people's concerns?");
  const moderatorView = await moderator.chat("What feedback am I getting?", {
    sessionId: groupChat.id
  });
  ```
</CodeGroup>

### LLM Integration

<CodeGroup>
  ```python Python
  import openai

  # Get conversation context
  context = session.get_context(tokens=3000)
  messages = context.to_openai(assistant=assistant)

  # Call OpenAI API
  response = openai.chat.completions.create(
      model="gpt-4",
      messages=messages + [
          {"role": "user", "content": "Summarize the key discussion points."}
      ]
  )
  ```

  ```typescript TypeScript
  import OpenAI from 'openai';

  const openai = new OpenAI();

  // Get conversation context
  const context = await session.getContext({ tokens: 3000 });
  const messages = context.toOpenAI(assistant);

  // Call OpenAI API
  const response = await openai.chat.completions.create({
    model: "gpt-4",
    messages: [
      ...messages,
      { role: "user", content: "Summarize the key discussion points." }
    ]
  });
  ```
</CodeGroup>

### Custom Message Timestamps

When creating messages, you can optionally specify a custom `created_at` timestamp instead of using the server's current time:

```bash
curl -X POST "https://api.honcho.dev/v2/workspaces/{workspace_id}/sessions/{session_id}/messages" \
  -H "Authorization: Bearer $API_KEY" \
  -H "Content-Type: application/json" \
  -d '{
    "messages": [
      {
        "peer_id": "user123",
        "content": "This message happened yesterday",
        "created_at": "2024-01-01T12:00:00Z",
        "metadata": {"source": "historical_data"}
      }
    ]
  }'
```

This is useful for:

* Importing historical conversation data
* Backfilling messages from other systems
* Maintaining accurate timeline ordering when processing batch data

If `created_at` is not provided, messages will use the server's current timestamp.

### Metadata and Filtering

See [Using Filters](/v2/guides/using-filters) for more examples on how to use filters.

<CodeGroup>
  ```python Python
  # Add messages with metadata
  session.add_messages([
      alice.message("Let's discuss the budget", metadata={
          "topic": "finance",
          "priority": "high"
      }),
      assistant.message("I'll prepare the financial report", metadata={
          "action_item": True,
          "due_date": "2024-01-15"
      })
  ])

  # Filter messages by metadata
  finance_messages = session.get_messages(filters={"metadata": {"topic": "finance"}})
  action_items = session.get_messages(filters={"metadata": {"action_item": True}})
  ```

  ```typescript TypeScript
  // Add messages with metadata
  await session.addMessages([
    alice.message("Let's discuss the budget", {
      metadata: {
        topic: "finance",
        priority: "high"
      }
    }),
    assistant.message("I'll prepare the financial report", {
      metadata: {
        action_item: true,
        due_date: "2024-01-15"
      }
    })
  ]);

  // Filter messages by metadata
  const financeMessages = await session.getMessages({
    filters: { metadata: { topic: "finance" } }
  });
  const actionItems = await session.getMessages({
    filters: { metadata: { action_item: true } }
  });
  ```
</CodeGroup>

### Pagination

<CodeGroup>
  ```python Python
  # Iterate through all sessions
  for session in honcho.get_sessions():
      print(f"Session: {session.id}")

      # Iterate through session messages
      for message in session.get_messages():
          print(f"  {message.peer_id}: {message.content}")
  ```

  ```typescript TypeScript
  // Get paginated results
  const peersPage = await honcho.getPeers();

  // Iterate through all items
  for await (const peer of peersPage) {
    console.log(`Peer: ${peer.id}`);
  }

  // Manual pagination
  let currentPage = peersPage;
  while (currentPage) {
    const data = await currentPage.data();
    console.log(`Processing ${data.length} items`);
    currentPage = await currentPage.nextPage();
  }
  ```
</CodeGroup>

## Best Practices

### Resource Management

<CodeGroup>
  ```python Python
  # Peers and sessions are lightweight - create as needed
  alice = honcho.peer("alice")
  session = honcho.session("chat-1")

  # Use descriptive IDs for better debugging
  user_session = honcho.session(f"user-{user_id}-support-{ticket_id}")
  support_agent = honcho.peer(f"agent-{agent_id}")
  ```

  ```typescript TypeScript
  // Peers and sessions are lightweight - create as needed
  const alice = await honcho.peer("alice");
  const session = await honcho.session("chat-1");

  // Use descriptive IDs for better debugging
  const userSession = await honcho.session(`user-${userId}-support-${ticketId}`);
  const supportAgent = await honcho.peer(`agent-${agentId}`);
  ```
</CodeGroup>

### Performance Optimization

<CodeGroup>
  ```python Python
  # Lazy creation - no API calls until needed
  peers = [honcho.peer(f"user-{i}") for i in range(100)]  # Fast

  # Batch operations when possible
  session.add_messages([peer.message(f"Message {i}") for i, peer in enumerate(peers)])

  # Use context limits to control token usage
  context = session.get_context(tokens=1500)  # Limit context size
  ```

  ```typescript TypeScript
  // Lazy creation - no API calls until needed
  const peers = await Promise.all(
    Array.from({ length: 100 }, (_, i) => honcho.peer(`user-${i}`))
  );

  // Batch operations when possible
  await session.addMessages(
    peers.map((peer, i) => peer.message(`Message ${i}`))
  );

  // Use context limits to control token usage
  const context = await session.getContext({ tokens: 1500 }); // Limit context size

  // Iterate efficiently with async iteration
  for await (const peer of await honcho.getPeers()) {
    // Process one peer at a time without loading all into memory
  }
  ```
</CodeGroup>


# Dialectic Endpoint
Source: https://docs.honcho.dev/v2/guides/dialectic-endpoint

An endpoint for reasoning about your users

Honcho by default runs ambient inference on top of the `message` objects you store. Those messages serve as the ground truth upon which facts about the user are derived and stored. The **Dialectic Endpoint** is the natural language interface through which insights are synthesized from those facts. We believe [intellectual respect](https://blog.plasticlabs.ai/extrusions/Extrusion-02.24) for LLMs is paramount in building effective AI agents/apps. It follows that the LLM should know better than any human what would aid them in their generation task. Thus, the Dialectic endpoint exists for flexible agent-to-agent communication.

## Automatic Fact Derivation

On every message written to a session, an automatic callback is run that will reason about the conversation and store facts in a `collection` named `honcho`. This is a reserved `collection` specifically for the backend Honcho agent to interact with.

## Dialectic Endpoint

The Dialectic endpoint allows you to define logic enabling your agent to talk to our agent that automatically retrieves and synthesizes facts from the collection. You can use the response as part of your reasoning process for your agent–add it to your next prompt to inject critical context about the user.

This chat interface is exposed via the `peer.chat()` endpoint. It accepts a string query. Below is some example code on how this works.

## Prerequisites

<CodeGroup>
  ```python Python
  from honcho import Honcho

  # use the default workspace
  honcho = Honcho()

  # get/create a peer
  peer = honcho.peer("demo-user")

  # get/create a session
  session = honcho.session("demo-session")

  # (assuming some messages have been written to Honcho for the deriver to use)
  ```

  ```typescript TypeScript
  import { Honcho } from '@honcho-ai/sdk';

  // use the default workspace
  const honcho = new Honcho({});

  // get/create a peer
  const peer = await honcho.peer('demo-user');

  // get/create a session
  const session = await honcho.session('demo-session');

  // (assuming some messages have been written to Honcho for the deriver to use)
  ```
</CodeGroup>

## Static Dialectic Call

<CodeGroup>
  ```python Python
  query = "What is the user's favorite way of completing the task?"
  answer = peer.chat(query)
  ```

  ```typescript TypeScript
  const query = "What is the user's favorite way of completing the task?"
  const dialecticResponse = await peer.chat(query)
  ```
</CodeGroup>

## Streaming Dialectic Call

<CodeGroup>
  ```python Python
  query = "What do we know about the user?"
  response_stream = peer.chat(query, stream=True)

  for line in response_stream.iter_text():
      print(line)
  ```

  ```typescript TypeScript
  const query = "What do we know about the user?"
  const responseStream = await peer.chat(query, { stream: true })

  for await (const line of responseStream.iter_text()) {
      console.log(line)
  }
  ```
</CodeGroup>

We've designed the Dialectic endpoint to be infinitely flexible. We wrote an incomplete list of ideas on how to use it on our blog [here](https://blog.plasticlabs.ai/blog/Introducing-Honcho's-Dialectic-API#how-it-works).


# Discord Bots with Honcho
Source: https://docs.honcho.dev/v2/guides/discord

Use Honcho to build a Discord bot with conversational memory and context management.

> Example code is available on [GitHub](https://github.com/plastic-labs/discord-python-starter)

Any application interface that defines logic based on events and supports
special commands can work easily with Honcho. Here's how to use Honcho with
**Discord** as an interface. If you're not familiar with Discord bot
application logic, the [py-cord](https://pycord.dev/) docs would be a good
place to start.

## Events

Most Discord bots have async functions that listen for specific events, the most common one being messages. We can use Honcho to store messages by user and session based on an interface's event logic. Take the following function definition for example:

```python
@bot.event
async def on_message(message):
    """
    Receive a message from Discord and respond with a message from our LLM assistant.
    """
    if not validate_message(message):
        return

    input = sanitize_message(message)

    # If the message is empty after sanitizing, ignore it
    if not input:
        return

    peer = honcho_client.peer(id=get_peer_id_from_discord(message))
    session = honcho_client.session(id=str(message.channel.id))

    async with message.channel.typing():
        response = llm(session, input)

    await send_discord_message(message, response)

    # Save both the user's message and the bot's response to the session
    session.add_messages(
        [
            peer.message(input),
            assistant.message(response),
        ]
    )
```

Let's break down what this code is doing...

```python
@bot.event
async def on_message(message):
    if not validate_message(message):
        return
```

This is how you define an event function in `py-cord` that listens for messages. We use a helper function `validate_message()` to check if the message should be processed.

## Helper Functions

The code uses several helper functions to keep the main logic clean and readable. Let's examine each one:

### Message Validation

```python
def validate_message(message) -> bool:
    """
    Determine if the message is valid for the bot to respond to.
    Return True if it is, False otherwise. Currently, the bot will
    only respond to messages that tag it with an @mention in a
    public channel and are not from the bot itself.
    """
    if message.author == bot.user:
        # ensure the bot does not reply to itself
        return False

    if isinstance(message.channel, discord.DMChannel):
        return False

    if not bot.user.mentioned_in(message):
        return False

    return True
```

This function centralizes all the logic for determining whether the bot should respond to a message. It checks that:

* The message isn't from the bot itself
* The message isn't in a DM channel
* The bot is mentioned in the message

### Message Sanitization

```python
def sanitize_message(message) -> str | None:
    """Remove the bot's mention from the message content if present"""
    content = message.content.replace(f"<@{bot.user.id}>", "").strip()
    if not content:
        return None
    return content
```

This helper removes the bot's mention from the message content, leaving just the actual user input.

### Peer ID Generation

```python
def get_peer_id_from_discord(message):
    """Get a Honcho peer ID for the message author"""
    return f"discord_{str(message.author.id)}"
```

This creates a unique peer identifier for each Discord user by prefixing their Discord ID.

### LLM Integration

```python
def llm(session, prompt) -> str:
    """
    Call the LLM with the given prompt and chat history.

    You should expand this function with custom logic, prompts, etc.
    """
    messages: list[dict[str, object]] = session.get_context().to_openai(
        assistant=assistant
    )
    messages.append({"role": "user", "content": prompt})

    try:
        completion = openai.chat.completions.create(
            model=MODEL_NAME,
            messages=messages,
        )
        return completion.choices[0].message.content
    except Exception as e:
        print(e)
        return f"Error: {e}"
```

This function handles the LLM interaction. It uses Honcho's built-in `to_openai()` method to automatically convert the session context into the format expected by OpenAI's chat completions API.

### Message Sending

```python
async def send_discord_message(message, response_content: str):
    """Send a message to the Discord channel"""
    if len(response_content) > 1500:
        # Split response into chunks at newlines, keeping under 1500 chars
        chunks = []
        current_chunk = ""
        for line in response_content.splitlines(keepends=True):
            if len(current_chunk) + len(line) > 1500:
                chunks.append(current_chunk)
                current_chunk = line
            else:
                current_chunk += line
        if current_chunk:
            chunks.append(current_chunk)

        for chunk in chunks:
            await message.channel.send(chunk)
    else:
        await message.channel.send(response_content)
```

This function handles sending messages to Discord, automatically splitting long responses into multiple messages to stay within Discord's character limits.

## Honcho Integration

The new Honcho peer/session API makes integration much simpler:

```python
peer = honcho_client.peer(id=get_peer_id_from_discord(message))
session = honcho_client.session(id=str(message.channel.id))
```

Here we create a peer object for the user and a session object using the Discord channel ID. This automatically handles user and session management.

```python
# Save both the user's message and the bot's response to the session
session.add_messages(
    [
        peer.message(input),
        assistant.message(response),
    ]
)
```

After generating the response, we save both the user's input and the bot's response to the session using the `add_messages()` method. The `peer.message()` creates a message from the user, while `assistant.message()` creates a message from the assistant.

## Slash Commands

Discord bots also offer slash command functionality. Here's an example using Honcho's dialectic feature:

```python
@bot.slash_command(
    name="dialectic",
    description="Query the Honcho Dialectic endpoint.",
)
async def dialectic(ctx, query: str):
    await ctx.defer()

    try:
        peer = honcho_client.peer(id=get_peer_id_from_discord(ctx))
        session = honcho_client.session(id=str(ctx.channel.id))

        response = peer.chat(
            query=query,
            session_id=session.id,
        )

        if response:
            await ctx.followup.send(response)
        else:
            await ctx.followup.send(
                f"I don't know anything about {ctx.author.name} because we haven't talked yet!"
            )
    except Exception as e:
        logger.error(f"Error calling Dialectic API: {e}")
        await ctx.followup.send(
            f"Sorry, there was an error processing your request: {str(e)}"
        )
```

This slash command uses Honcho's dialectic functionality to answer questions about the user based on their conversation history.

## Setup and Configuration

The bot requires several environment variables and setup:

```python
honcho_client = Honcho()
assistant = honcho_client.peer(id="assistant", config={"observe_me": False})
openai = OpenAI(base_url="https://openrouter.ai/api/v1", api_key=MODEL_API_KEY)
```

* `honcho_client`: The main Honcho client
* `assistant`: A peer representing the bot/assistant
* `openai`: OpenAI client configured to use OpenRouter

## Recap

The new Honcho peer/session API makes Discord bot integration much simpler and more intuitive. Key patterns we learned:

* **Peer/Session Model**: Users are represented as peers, conversations as sessions
* **Automatic Context Management**: `session.get_context().to_openai()` automatically formats chat history
* **Message Storage**: `session.add_messages()` stores both user and assistant messages
* **Dialectic Queries**: `peer.chat()` enables querying conversation history
* **Helper Functions**: Clean code organization with focused helper functions

This approach provides a clean, maintainable structure for building Discord bots with conversational memory and context management.


# Working with Session Context
Source: https://docs.honcho.dev/v2/guides/get-context

Learn how to use get_context() to retrieve and format conversation context for LLM integration

The `get_context()` method is a powerful feature that retrieves formatted conversation context from sessions, making it easy to integrate with LLMs like OpenAI, Anthropic, and others. This guide covers everything you need to know about working with session context.

By default, the context includes a blend of summary and messages which covers the entire history of the session. Summaries are automatically generated at intervals and recent messages are included depending on how many tokens the context is intended to be. You can specify any token limit you want, and can disable summaries to fill that limit entirely with recent messages.

## Basic Usage

The `get_context()` method is available on all Session objects and returns a `SessionContext` that contains the formatted conversation history.

<CodeGroup>
  ```python Python
  from honcho import Honcho

  # Initialize client and create session
  honcho = Honcho()
  session = honcho.session("conversation-1")

  # Get basic context (not very useful before adding any messages!)
  context = session.get_context()
  ```

  ```typescript TypeScript
  import { Honcho } from "@honcho-ai/sdk";

  (async () => {
      // Initialize client and create session
      const honcho = new Honcho({});
      const session = await honcho.session("conversation-1");

      // Get basic context (not very useful before adding any messages!)
      const context = await session.getContext();
  })();
  ```
</CodeGroup>

## Context Parameters

The `get_context()` method accepts several optional parameters to customize the retrieved context:

### Token Limits

Control the size of the context by setting a maximum token count:

<CodeGroup>
  ```python Python
  # Limit context to 1500 tokens
  context = session.get_context(tokens=1500)

  # Limit context to 3000 tokens for larger conversations
  context = session.get_context(tokens=3000)
  ```

  ```typescript TypeScript
  (async () => {
      // Limit context to 1500 tokens
      const context = await session.getContext({ tokens: 1500 });

      // Limit context to 3000 tokens for larger conversations
      const context = await session.getContext({ tokens: 3000 });
  })();
  ```
</CodeGroup>

### Summary Mode

Enable summary mode (on by default) to get a condensed version of the conversation:

<CodeGroup>
  ```python Python
  # Get context with summary enabled -- will contain both summary and messages
  context = session.get_context(summary=True)

  # Combine summary=False with token limits to get more messages
  context = session.get_context(summary=False, tokens=2000)
  ```

  ```typescript TypeScript
  (async () => {
      // Get context with summary enabled -- will contain both summary and messages
      const context = await session.getContext({ summary: true });

      // Combine summary=False with token limits to get more messages
      const context = await session.getContext({
        summary: false,
        tokens: 2000
      });
  })();
  ```
</CodeGroup>

## Converting to LLM Formats

The `SessionContext` object provides methods to convert the context into formats compatible with popular LLM APIs. When converting to OpenAI format, you must specify the assistant peer to format the context in such a way that the LLM can understand it.

### OpenAI Format

Convert context to OpenAI's chat completion format:

<CodeGroup>
  ```python Python
  # Create peers
  alice = honcho.peer("alice")
  assistant = honcho.peer("assistant")

  # Add some conversation
  session.add_messages([
      alice.message("What's the weather like today?"),
      assistant.message("It's sunny and 75°F outside!")
  ])

  # Get context and convert to OpenAI format
  context = session.get_context()
  openai_messages = context.to_openai(assistant=assistant)

  # The messages are now ready for OpenAI API
  print(openai_messages)
  # [
  #   {"role": "user", "content": "What's the weather like today?"},
  #   {"role": "assistant", "content": "It's sunny and 75°F outside!"}
  # ]
  ```

  ```typescript TypeScript
  (async () => {
      // Create peers
      const alice = await honcho.peer("alice");
      const assistant = await honcho.peer("assistant");

      // Add some conversation
      await session.addMessages([
        alice.message("What's the weather like today?"),
        assistant.message("It's sunny and 75°F outside!")
      ]);

      // Get context and convert to OpenAI format
      const context = await session.getContext();
      const openaiMessages = context.toOpenAI(assistant);

      // The messages are now ready for OpenAI API
      console.log(openaiMessages);
      // [
      //   {"role": "user", "content": "What's the weather like today?"},
      //   {"role": "assistant", "content": "It's sunny and 75°F outside!"}
      // ]
  })();
  ```
</CodeGroup>

### Anthropic Format

Convert context to Anthropic's Claude format:

<CodeGroup>
  ```python Python
  # Get context and convert to Anthropic format
  context = session.get_context()
  anthropic_messages = context.to_anthropic(assistant=assistant)

  # Ready for Anthropic API
  print(anthropic_messages)
  ```

  ```typescript TypeScript
  (async () => {
      // Get context and convert to Anthropic format
      const context = await session.getContext();
      const anthropicMessages = context.toAnthropic(assistant);

      // Ready for Anthropic API
      console.log(anthropicMessages);
  })();
  ```
</CodeGroup>

## Complete LLM Integration Examples

### Using with OpenAI

<CodeGroup>
  ```python Python
  import openai
  from honcho import Honcho

  # Initialize clients
  honcho = Honcho()
  openai_client = openai.OpenAI()

  # Set up conversation
  session = honcho.session("support-chat")
  user = honcho.peer("user-123")
  assistant = honcho.peer("support-bot")

  # Add conversation history
  session.add_messages([
      user.message("I'm having trouble with my account login"),
      assistant.message("I can help you with that. What error message are you seeing?"),
      user.message("It says 'Invalid credentials' but I'm sure my password is correct")
  ])

  # Get context for LLM
  messages = session.get_context(tokens=2000).to_openai(assistant=assistant)

  # Add new user message and get AI response
  messages.append({
      "role": "user",
      "content": "Can you reset my password?"
  })

  response = openai_client.chat.completions.create(
      model="gpt-4",
      messages=messages
  )

  # Add AI response back to session
  session.add_messages([
      user.message("Can you reset my password?"),
      assistant.message(response.choices[0].message.content)
  ])
  ```

  ```typescript TypeScript
  import OpenAI from 'openai';
  import { Honcho } from "@honcho-ai/sdk";

  (async () => {
      // Initialize clients
      const honcho = new Honcho({});
      const openai = new OpenAI();

      // Set up conversation
      const session = await honcho.session("support-chat");
      const user = await honcho.peer("user-123");
      const assistant = await honcho.peer("support-bot");

      // Add conversation history
      await session.addMessages([
        user.message("I'm having trouble with my account login"),
        assistant.message("I can help you with that. What error message are you seeing?"),
        user.message("It says 'Invalid credentials' but I'm sure my password is correct")
      ]);

      // Get context for LLM
      const messages = await session.getContext({ tokens: 2000 }).toOpenAI(assistant);

      // Add new user message and get AI response
      const response = await openai.chat.completions.create({
        model: "gpt-4",
        messages: [
          ...messages,
          { role: "user", content: "Can you reset my password?" }
        ]
      });

      // Add AI response back to session
      await session.addMessages([
        user.message("Can you reset my password?"),
        assistant.message(response.choices[0].message.content)
      ]);
  })();
  ```
</CodeGroup>

### Multi-Turn Conversation Loop

<CodeGroup>
  ```python Python
  def chat_loop():
      """Example of a continuous chat loop using get_context()"""

      session = honcho.session("chat-session")
      user = honcho.peer("user")
      assistant = honcho.peer("ai-assistant")

      while True:
          # Get user input
          user_input = input("You: ")
          if user_input.lower() in ['quit', 'exit']:
              break

          # Add user message to session
          session.add_messages([user.message(user_input)])

          # Get conversation context
          context = session.get_context(tokens=2000)
          messages = context.to_openai(assistant=assistant)

          # Get AI response
          response = openai_client.chat.completions.create(
              model="gpt-4",
              messages=messages
          )

          ai_response = response.choices[0].message.content
          print(f"Assistant: {ai_response}")

          # Add AI response to session
          session.add_messages([assistant.message(ai_response)])

  # Start the chat loop
  chat_loop()
  ```

  ```typescript TypeScript
  (async () => {
      async function chatLoop() {
        const session = await honcho.session("chat-session");
        const user = await honcho.peer("user");
        const assistant = await honcho.peer("ai-assistant");

        // This would be replaced with actual user input handling in a real app
        const userInputs = [
          "Hello, how are you?",
          "What's the weather like?",
          "Tell me a joke"
        ];

        for (const userInput of userInputs) {
          console.log(`You: ${userInput}`);

          // Add user message to session
          await session.addMessages([user.message(userInput)]);

          // Get conversation context
          const context = await session.getContext({ tokens: 2000 });
          const messages = context.toOpenAI(assistant);

          // Get AI response
          const response = await openai.chat.completions.create({
            model: "gpt-4",
            messages: messages
          });

          const aiResponse = response.choices[0].message.content;
          console.log(`Assistant: ${aiResponse}`);

          // Add AI response to session
          await session.addMessages([assistant.message(aiResponse)]);
        }
      }

      // Start the chat loop
      await chatLoop();
  })();
  ```
</CodeGroup>

## Advanced Context Usage

### Context with Summaries for Long Conversations

For very long conversations, use summaries to maintain context while controlling token usage:

<CodeGroup>
  ```python Python
  # For long conversations, use summary mode
  long_session = honcho.session("long-conversation")

  # Get summarized context to fit within token limits
  context = long_session.get_context(summary=True, tokens=1500)
  messages = context.to_openai(assistant=assistant)

  # This will include a summary of older messages and recent full messages
  print(f"Context contains {len(messages)} formatted messages")
  ```

  ```typescript TypeScript
  (async () => {
      // For long conversations, use summary mode
      const longSession = await honcho.session("long-conversation");

      // Get summarized context to fit within token limits
      const context = await longSession.getContext({
        summary: true,
        tokens: 1500
      });
      const messages = context.toOpenAI(assistant);

      // This will include a summary of older messages and recent full messages
      console.log(`Context contains ${messages.length} formatted messages`);
  })();
  ```
</CodeGroup>

### Context for Different Assistant Types

You can get context formatted for different types of assistants in the same session:

<CodeGroup>
  ```python Python
  # Create different assistant peers
  chatbot = honcho.peer("chatbot")
  analyzer = honcho.peer("data-analyzer")
  moderator = honcho.peer("moderator")

  # Get context formatted for each assistant type
  chatbot_context = session.get_context().to_openai(assistant=chatbot)
  analyzer_context = session.get_context().to_openai(assistant=analyzer)
  moderator_context = session.get_context().to_openai(assistant=moderator)

  # Each context will format the conversation from that assistant's perspective
  ```

  ```typescript TypeScript
  (async () => {
      // Create different assistant peers
      const chatbot = await honcho.peer("chatbot");
      const analyzer = await honcho.peer("data-analyzer");
      const moderator = await honcho.peer("moderator");

      // Get context formatted for each assistant type
      const context = await session.getContext();
      const chatbotContext = context.toOpenAI(chatbot);
      const analyzerContext = context.toOpenAI(analyzer);
      const moderatorContext = context.toOpenAI(moderator);

      // Each context will format the conversation from that assistant's perspective
  })();
  ```
</CodeGroup>

## Best Practices

### 1. Token Management

Always set appropriate token limits to control costs and ensure context fits within LLM limits:

<CodeGroup>
  ```python Python
  # Good: Set reasonable token limits based on your model
  context = session.get_context(tokens=3000)  # For GPT-4
  context = session.get_context(tokens=1500)  # For smaller models

  # Good: Use summaries for very long conversations
  context = session.get_context(summary=True, tokens=2000)
  ```

  ```typescript TypeScript
  (async () => {
      // Good: Set reasonable token limits based on your model
      const context = await session.getContext({ tokens: 3000 });  // For GPT-4
      const context = await session.getContext({ tokens: 1500 });  // For smaller models

      // Good: Use summaries for very long conversations
      const context = await session.getContext({ summary: true, tokens: 2000 });
  })();
  ```
</CodeGroup>

### 2. Context Caching

For applications with frequent context retrieval, consider caching context when appropriate:

<CodeGroup>
  ```python Python
  # Cache context for multiple LLM calls within the same request
  context = session.get_context(tokens=2000)
  openai_messages = context.to_openai(assistant=assistant)
  anthropic_messages = context.to_anthropic(assistant=assistant)

  # Use the same context object for multiple format conversions
  ```

  ```typescript TypeScript
  (async () => {
      // Cache context for multiple LLM calls within the same request
      const context = await session.getContext({ tokens: 2000 });
      const openaiMessages = context.toOpenAI(assistant);
      const anthropicMessages = context.toAnthropic(assistant);

      // Use the same context object for multiple format conversions
  })();
  ```
</CodeGroup>

### 3. Error Handling

Always handle potential errors when working with context:

<CodeGroup>
  ```python Python
  try:
      context = session.get_context(tokens=2000)
      messages = context.to_openai(assistant=assistant)

      # Use messages with LLM API
      response = openai_client.chat.completions.create(
          model="gpt-4",
          messages=messages
      )

  except Exception as e:
      print(f"Error getting context: {e}")
      # Handle error appropriately
  ```

  ```typescript TypeScript
  (async () => {
      try {
        const context = await session.getContext({ tokens: 2000 });
        const messages = context.toOpenAI(assistant);

        // Use messages with LLM API
        const response = await openai.chat.completions.create({
          model: "gpt-4",
          messages: messages
        });

      } catch (error) {
        console.error(`Error getting context: ${error}`);
        // Handle error appropriately
      }
  })();
  ```
</CodeGroup>

## Conclusion

The `get_context()` method is essential for integrating Honcho sessions with LLMs. By understanding how to:

* Retrieve context with appropriate parameters
* Convert context to LLM-specific formats
* Manage token limits and summaries
* Handle multi-turn conversations

You can build sophisticated AI applications that maintain conversation history and context across interactions while integrating seamlessly with popular LLM providers.


# Honcho MCP
Source: https://docs.honcho.dev/v2/guides/mcp

Use Honcho in Claude Desktop

You can let Claude use Honcho to manage its own memory in the native desktop app by using the Honcho MCP integration! Follow these steps:

1. Go to [https://app.honcho.dev](https://app.honcho.dev) and get an API key. Then go to Claude Desktop and navigate to custom MCP servers.

<Note>
  If you don't have node installed you will need to do that. Claude Desktop or Claude Code can help!
</Note>

2. Add Honcho to your Claude desktop config. You must provide a username for Honcho to refer to you as -- preferably what you want Claude to actually call you.

```json
{
  "mcpServers": {
    "honcho": {
      "command": "npx",
      "args": [
        "mcp-remote",
        "https://mcp.honcho.dev",
        "--header",
        "Authorization:${AUTH_HEADER}",
        "--header",
        "X-Honcho-User-Name:${USER_NAME}"
      ],
      "env": {
        "AUTH_HEADER": "Bearer <your-honcho-key>",
        "USER_NAME": "<your-name>"
      }
    }
  }
}
```

You may customize your assistant name and/or workspace ID. Both are optional.

```json
{
  "mcpServers": {
    "honcho": {
      "command": "npx",
      "args": [
        "mcp-remote",
        "https://mcp.honcho.dev",
        "--header",
        "Authorization:${AUTH_HEADER}",
        "--header",
        "X-Honcho-User-Name:${USER_NAME}",
        "--header",
        "X-Honcho-Assistant-Name:${ASSISTANT_NAME}",
        "--header",
        "X-Honcho-Workspace-ID:${WORKSPACE_ID}"
      ],
      "env": {
        "AUTH_HEADER": "Bearer <your-honcho-key>",
        "USER_NAME": "<your-name>",
        "ASSISTANT_NAME": "<your-assistant-name>",
        "WORKSPACE_ID": "<your-custom-workspace-id>"
      }
    }
  }
}
```

3. Restart the Claude Desktop app. Upon relaunch, it should start Honcho and the tools should be available!

4. Finally, Claude needs instructions on how to use Honcho. The Desktop app doesn't allow you to add system prompts directly, but you can create a project and paste these [instructions](https://raw.githubusercontent.com/plastic-labs/honcho/refs/heads/main/mcp/instructions.md) into the "Project Instructions" field.

Claude should then query for insights before responding and write your messages to storage! If you come up with more creative ways to get Claude to manage its own memory with Honcho, feel free to [let us know](https://discord.gg/plasticlabs) or make a PR on this [repo](https://github.com/plastic-labs/honcho/tree/main/mcp)!


# Spellbooks and Tutorials
Source: https://docs.honcho.dev/v2/guides/overview

Helpful guides and design patterns for building with Honcho

<Note> Before you start a tutorial, follow [Quickstart](/v2/documentation/introduction/quickstart) to get up and running with Honcho in your language of choice. </Note>

AI development often feels like magic - you craft the right prompt and get exactly what you need. Our Spellbooks are practical guides that show you how to cast effective spells with Honcho.

Whether you're integrating Honcho into existing platforms, exploring advanced features, or getting up and running quickly, these guides provide concrete examples and implementation patterns.

## What You'll Find Here

### Getting Started

**[Overview](overview)** - You are here
**[AI-Assisted Setup](ai-assisted-setup)** - Get Honcho running with a single prompt in Cursor or Claude Code

### Application Interfaces

Ready-to-use integration patterns for popular platforms:

**[Discord Bot](discord)** - Build a Discord bot that remembers users across conversations
**[Telegram Bot](telegram)** - Create a Telegram bot with persistent user understanding

### Design Patterns

Implementation patterns for Honcho's core capabilities

**[Dialectic Endpoint](dialectic-endpoint)** - Query user psychology in natural language
**[Working with Session Context](get-context)** - Manage conversation flow and context windows
**[Search](search)** - Search your data using natural language
**[Working Representations](working-representations)** - Understanding and customizing user models
**[Streaming Responses](streaming-responses)** - Handle real-time interactions efficiently
**[Using Filters](using-filters)** - Control what data gets processed and how
**[File Uploads](file-uploads)** - Upload PDF, text, or JSON files to create messages

## Philosophy

These aren't just API documentation - they're implementation patterns that solve real problems. Each spellbook focuses on a specific use case with working code you can adapt to your needs.

The goal is to get you from idea to working prototype as quickly as possible, then provide the depth you need to scale and customize.


# Search
Source: https://docs.honcho.dev/v2/guides/search

Learn how to search across workspaces, sessions, and peers to find relevant conversations and content

Honcho's search functionality allows you to find relevant messages and conversations across different scopes - from entire workspaces down to specific peers or sessions.

## Search Scopes

### Workspace Search

Search across all content in your workspace - sessions, peers, and messages:

<CodeGroup>
  ```python Python
  from honcho import Honcho

  # Initialize client
  honcho = Honcho()

  # Search across entire workspace
  results = honcho.search("budget planning")

  # Iterate through all results
  for result in results:
      print(f"Found: {result}")
  ```

  ```typescript TypeScript
  import { Honcho } from "@honcho-ai/sdk";

  (async () => {
      // Initialize client
      const honcho = new Honcho({});

      // Search across entire workspace
      const results = await honcho.search("budget planning");

      // Iterate through all results
      for (const result of results) {
        console.log(`Found: ${result}`);
      }
  })();
  ```
</CodeGroup>

### Session Search

Search within a specific session's conversation history:

<CodeGroup>
  ```python Python
  # Create or get a session
  session = honcho.session("team-meeting-jan")

  # Search within this session only
  results = session.search("action items")

  # Process results
  for result in results:
      print(f"Session result: {result}")
  ```

  ```typescript TypeScript
  (async () => {
      // Create or get a session
      const session = await honcho.session("team-meeting-jan");

      // Search within this session only
      const results = await session.search("action items");

      // Process results
      for (const result of results) {
        console.log(`Session result: ${result}`);
      }
  })();
  ```
</CodeGroup>

### Peer Search

Search across all content associated with a specific peer:

<CodeGroup>
  ```python Python
  # Create or get a peer
  alice = honcho.peer("alice")

  # Search across all of Alice's messages and interactions
  results = alice.search("programming")

  # View results
  for result in results:
      print(f"Alice's content: {result}")
  ```

  ```typescript TypeScript
  import { Message } from "@honcho-ai/sdk";

  (async () => {
      // Create or get a peer
      const alice = await honcho.peer("alice");

      // Search across all of Alice's messages and interactions
      const results: Message[] = await alice.search("programming");

      // View results
      for (const result of results) {
        console.log(`Alice's content: ${result.content}`);
      }
  })();
  ```
</CodeGroup>

## Filters and Limits

### Get a specific number of results

You can specify the number of results you want to return by passing the `limit` parameter to the search method. The default is 10 results, with a maximum of 100.

<CodeGroup>
  ```python Python
  results = honcho.search("budget planning", limit=20)
  ```

  ```typescript TypeScript
  (async () => {
      const results = await honcho.search("budget planning", { limit: 20 });
  })();
  ```
</CodeGroup>

### Get messages from a Peer in a specific Session

Combine Peer-level search with a `session_id` filter to get messages from a Peer in a specific Session.

<CodeGroup>
  ```python Python
  my_peer = honcho.peer("my-peer")
  my_session = honcho.session("team-meeting-jan")
  results = my_peer.search("budget planning", filters={"session_id": my_session.id})
  ```

  ```typescript TypeScript
  (async () => {
      const my_peer = await honcho.peer("my-peer");
      const my_session = await honcho.session("team-meeting-jan");
      const results = await my_peer.search("budget planning", { filters: { session_id: my_session.id } });
  })();
  ```
</CodeGroup>

Search returns an object containing an `items` array of message objects:

```json
{
  "items": [
    {
      "id": "<string>",
      "content": "<string>",
      "peer_id": "<string>",
      "session_id": "<string>",
      "metadata": {},
      "created_at": "2023-11-07T05:31:56Z",
      "workspace_id": "<string>",
      "token_count": 123
    }
  ]
}
```

### Filter results by time range

<CodeGroup>
  ```python Python
  results = honcho.search("budget planning", filters={"created_at": {"gte": "2024-01-01", "lte": "2024-01-31"}})
  ```

  ```typescript TypeScript
  (async () => {
      const results = await honcho.search("budget planning", { filters: { created_at: { gte: "2024-01-01", lte: "2024-01-31" } } });
  })();
  ```
</CodeGroup>

### Filter results by metadata

<CodeGroup>
  ```python Python
  results = honcho.search("budget planning", filters={"metadata": {"key": "value"}})
  ```

  ```typescript TypeScript
  (async () => {
      const results = await honcho.search("budget planning", { filters: { metadata: { key: "value" } } });
  })();
  ```
</CodeGroup>

### Best Practices

### Handle Empty Results Gracefully

<CodeGroup>
  ```python Python
  # Always check for empty results
  results = honcho.search("very specific query")
  result_list = list(results)

  if result_list:
      print(f"Found {len(result_list)} results")
      for result in result_list:
          print(f"- {result}")
  else:
      print("No results found - try a broader search")
  ```

  ```typescript TypeScript
  import { Message } from "@honcho-ai/sdk";

  (async () => {
      // Always check for empty results
      const results: Message[] = await honcho.search("very specific query");

      if (results.length > 0) {
        console.log(`Found ${results.length} results`);
        for (const result of results) {
          console.log(`- ${result.content}`);
        }
      } else {
        console.log("No results found - try a broader search");
      }
  })();
  ```
</CodeGroup>

## Conclusion

Honcho's search functionality provides powerful discovery capabilities across your conversational data. By understanding how to:

* Choose the appropriate search scope (workspace, session, or peer)
* Handle paginated results effectively
* Combine search with context building

You can build applications that provide intelligent insights and context-aware responses based on historical conversations and interactions.


# Streaming Responses
Source: https://docs.honcho.dev/v2/guides/streaming-response

Using streaming responses with Honcho SDKs

When working with AI-generated content, streaming the response as it's generated can significantly improve the user experience. Honcho provides streaming functionality in its SDKs that allows your application to display content as it's being generated, rather than waiting for the complete response.

## When to Use Streaming

Streaming is particularly useful for:

* Real-time chat interfaces
* Long-form content generation
* Applications where perceived speed is important
* Interactive agent experiences
* Reducing time-to-first-word in user interactions

## Streaming with the Dialectic Endpoint

One of the primary use cases for streaming in Honcho is with the Dialectic endpoint. This allows you to stream the AI's reasoning about a user in real-time.

### Prerequisites

<CodeGroup>
  ```python Python
  from honcho import Honcho

  # Initialize client (using the default workspace)
  honcho = Honcho()

  # Create or get peers
  user = honcho.peer("demo-user")
  assistant = honcho.peer("assistant")

  # Create a new session
  session = honcho.session("demo-session")

  # Add peers to the session
  session.add_peers([user, assistant])

  # Store some messages for context (optional)
  session.add_messages([
      user.message("Hello, I'm testing the streaming functionality")
  ])
  ```

  ```typescript TypeScript
  import { Honcho } from '@honcho-ai/sdk';

  (async () => {
      // Initialize client (using the default workspace)
      const honcho = new Honcho({});

      // Create or get peers
      const user = await honcho.peer('demo-user');
      const assistant = await honcho.peer('assistant');

      // Create a new session
      const session = await honcho.session('demo-session');

      // Add peers to the session
      await session.addPeers([user, assistant]);

      // Store some messages for context (optional)
      await session.addMessages([
        user.message("Hello, I'm testing the streaming functionality")
      ]);
  })();
  ```
</CodeGroup>

## Streaming from the Dialectic Endpoint

<CodeGroup>
  ```python Python
  import time

  # Basic streaming example
  response_stream = user.chat("What can you tell me about this user?", stream=True)

  for chunk in response_stream.iter_text():
      print(chunk, end="", flush=True)  # Print each chunk as it arrives
      time.sleep(0.01)  # Optional delay for demonstration
  ```

  ```typescript TypeScript
  (async () => {
      // Basic streaming example
      const responseStream = await user.chat("What can you tell me about this user?", {
        stream: true
      });

      // Process the stream
      for await (const chunk of responseStream.iter_text()) {
        process.stdout.write(chunk);  // Write to console without newlines
      }
  })();
  ```
</CodeGroup>

## Working with Streaming Data

When working with streaming responses, consider these patterns:

1. **Progressive Rendering** - Update your UI as chunks arrive instead of waiting for the full response
2. **Buffered Processing** - Accumulate chunks until a logical break (like a sentence or paragraph)
3. **Token Counting** - Monitor token usage in real-time for applications with token limits
4. **Error Handling** - Implement appropriate error handling for interrupted streams

## Example: Restaurant Recommendation Chat

<CodeGroup>
  ```python Python
  import asyncio
  from honcho import Honcho

  async def restaurant_recommendation_chat():
      # Initialize client
      honcho = Honcho()

      # Create peers
      user = honcho.peer("food-lover")
      assistant = honcho.peer("restaurant-assistant")

      # Create session
      session = honcho.session("food-preferences-session")

      # Add peers to session
      await session.add_peers([user, assistant])

      # Store multiple user messages about food preferences
      user_messages = [
          "I absolutely love spicy Thai food, especially curries with coconut milk.",
          "Italian cuisine is another favorite - fresh pasta and wood-fired pizza are my weakness!",
          "I try to eat vegetarian most of the time, but occasionally enjoy seafood.",
          "I can't handle overly sweet desserts, but love something with dark chocolate."
      ]

      # Add the user's messages to the session
      session_messages = [user.message(message) for message in user_messages]
      await session.add_messages(session_messages)

      # Print the user messages
      for message in user_messages:
          print(f"User: {message}")

      # Ask for restaurant recommendations based on preferences
      print("\nRequesting restaurant recommendations...")
      print("Assistant: ", end="", flush=True)
      full_response = ""

      # Stream the response using the user's peer to get recommendations
      response_stream = user.chat(
          "Based on this user's food preferences, recommend 3 restaurants they might enjoy in the Lower East Side.",
          stream=True,
          session_id=session.id
      )

      for chunk in response_stream.iter_text():
          print(chunk, end="", flush=True)
          full_response += chunk
          await asyncio.sleep(0.01)

      # Store the assistant's complete response
      await session.add_messages([
          assistant.message(full_response)
      ])

  # Run the async function
  if __name__ == "__main__":
      asyncio.run(restaurant_recommendation_chat())
  ```

  ```typescript TypeScript
  import { Honcho } from '@honcho-ai/sdk';

  (async () => {
      async function restaurantRecommendationChat() {
        // Initialize client
        const honcho = new Honcho({});

        // Create peers
        const user = await honcho.peer('food-lover');
        const assistant = await honcho.peer('restaurant-assistant');

        // Create session
        const session = await honcho.session('food-preferences-session');

        // Add peers to session
        await session.addPeers([user, assistant]);

        // Store multiple user messages about food preferences
        const userMessages = [
          "I absolutely love spicy Thai food, especially curries with coconut milk.",
          "Italian cuisine is another favorite - fresh pasta and wood-fired pizza are my weakness!",
          "I try to eat vegetarian most of the time, but occasionally enjoy seafood.",
          "I can't handle overly sweet desserts, but love something with dark chocolate."
        ];

        // Add the user's messages to the session
        const sessionMessages = userMessages.map(message => user.message(message));
        await session.addMessages(sessionMessages);

        // Print the user messages
        for (const message of userMessages) {
          console.log(`User: ${message}`);
        }

        // Ask for restaurant recommendations based on preferences
        console.log("\nRequesting restaurant recommendations...");
        process.stdout.write("Assistant: ");
        let fullResponse = "";

        // Stream the response using the user's peer to get recommendations
        const responseStream = await user.chat(
          "Based on this user's food preferences, recommend 3 restaurants they might enjoy in the Lower East Side.",
          {
            stream: true,
            sessionId: session.id
          }
        );

        for await (const chunk of responseStream.iter_text()) {
          process.stdout.write(chunk);
          fullResponse += chunk;
        }

        // Store the assistant's complete response
        await session.addMessages([
          assistant.message(fullResponse)
        ]);
      }

      await restaurantRecommendationChat();
  })();
  ```
</CodeGroup>

## Performance Considerations

When implementing streaming:

* Consider connection stability for mobile or unreliable networks
* Implement appropriate timeouts for stream operations
* Be mindful of memory usage when accumulating large responses
* Use appropriate error handling for network interruptions

Streaming responses provide a more interactive and engaging user experience. By implementing streaming in your Honcho applications, you can create more responsive AI-powered features that feel natural and immediate to your users.


# Telegram Bots with Honcho
Source: https://docs.honcho.dev/v2/guides/telegram

Use Honcho to build a Telegram bot with conversational memory and context management.

> Example code is available on [GitHub](https://github.com/plastic-labs/telegram-python-starter)

Any application interface that defines logic based on events and supports
special commands can work easily with Honcho. Here's how to use Honcho with
**Telegram** as an interface. If you're not familiar with Telegram bot
development, the [python-telegram-bot](https://docs.python-telegram-bot.org/en/stable/) docs would be a good
place to start.

## Message Handling

Most Telegram bots have async functions that handle incoming messages. We can use Honcho to store messages by user and session based on the chat context. Take the following function definition for example:

```python
async def handle_message(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """
    Receive a message from Telegram and respond with a message from our LLM assistant.
    """
    if not validate_message(update, context):
        return

    message_text = update.effective_message.text
    input_text = sanitize_message(message_text, context.bot.username)

    # If the message is empty after sanitizing, ignore it
    if not input_text:
        return

    peer = honcho_client.peer(id=get_peer_id_from_telegram(update))
    session = honcho_client.session(id=str(update.effective_chat.id))

    # Send typing indicator
    await context.bot.send_chat_action(
        chat_id=update.effective_chat.id, action="typing"
    )

    response = llm(session, input_text)

    await send_telegram_message(update, context, response)

    # Save both the user's message and the bot's response to the session
    session.add_messages(
        [
            peer.message(input_text),
            assistant.message(response),
        ]
    )
```

Let's break down what this code is doing...

```python
async def handle_message(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if not validate_message(update, context):
        return
```

This is how you define a message handler in `python-telegram-bot` that processes incoming messages. We use a helper function `validate_message()` to check if the message should be processed.

## Helper Functions

The code uses several helper functions to keep the main logic clean and readable. Let's examine each one:

### Message Validation

```python
def validate_message(update: Update, context: ContextTypes.DEFAULT_TYPE) -> bool:
    """
    Determine if the message is valid for the bot to respond to.
    Return True if it is, False otherwise. The bot will respond to:
    - Direct messages (private chats)
    - Group messages that mention the bot or reply to it
    - Messages that are not from the bot itself
    """
    message = update.effective_message

    if not message or not message.text:
        return False

    # Don't respond to our own messages
    if message.from_user.id == context.bot.id:
        return False

    # Always respond in private chats
    if update.effective_chat.type == "private":
        return True

    # In groups, only respond if mentioned or replied to
    if (
        message.reply_to_message
        and message.reply_to_message.from_user.id == context.bot.id
    ):
        return True

    # Check if bot is mentioned
    if message.entities:
        for entity in message.entities:
            if entity.type == "mention":
                username = message.text[entity.offset : entity.offset + entity.length]
                if username == f"@{context.bot.username}":
                    return True

    return False
```

This function centralizes all the logic for determining whether the bot should respond to a message. It handles different chat types:

* **Private chats**: Always respond
* **Group chats**: Only respond when mentioned or when replying to the bot's messages
* **Bot prevention**: Never respond to the bot's own messages

### Message Sanitization

```python
def sanitize_message(message_text: str, bot_username: str) -> str | None:
    """Remove the bot's mention from the message content if present"""
    content = message_text.replace(f"@{bot_username}", "").strip()
    if not content:
        return None
    return content
```

This helper removes the bot's mention from the message content, leaving just the actual user input.

### Peer ID Generation

```python
def get_peer_id_from_telegram(update: Update) -> str:
    """Get a Honcho peer ID for the message author"""
    return f"telegram_{update.effective_user.id}"
```

This creates a unique peer identifier for each Telegram user by prefixing their Telegram user ID.

### LLM Integration

```python
def llm(session, prompt) -> str:
    """
    Call the LLM with the given prompt and chat history.

    You should expand this function with custom logic, prompts, etc.
    """
    messages: list[dict[str, object]] = session.get_context().to_openai(
        assistant=assistant
    )
    messages.append({"role": "user", "content": prompt})

    try:
        completion = openai.chat.completions.create(
            model=MODEL_NAME,
            messages=messages,
        )
        return completion.choices[0].message.content
    except Exception as e:
        logger.error(f"LLM error: {e}")
        return f"Error: {e}"
```

This function handles the LLM interaction. It uses Honcho's built-in `to_openai()` method to automatically convert the session context into the format expected by OpenAI's chat completions API.

### Message Sending

```python
async def send_telegram_message(
    update: Update, context: ContextTypes.DEFAULT_TYPE, response_content: str
):
    """Send a message to the Telegram chat, splitting if necessary"""
    # Telegram has a 4096 character limit, but we'll use 4000 to be safe
    max_length = 4000

    if len(response_content) <= max_length:
        await update.effective_message.reply_text(response_content)
    else:
        # Split response into chunks at newlines, keeping under max_length chars
        chunks = []
        current_chunk = ""

        for line in response_content.splitlines(keepends=True):
            if len(current_chunk) + len(line) > max_length:
                if current_chunk:
                    chunks.append(current_chunk)
                current_chunk = line
            else:
                current_chunk += line

        if current_chunk:
            chunks.append(current_chunk)

        for chunk in chunks:
            await update.effective_message.reply_text(chunk)
```

This function handles sending messages to Telegram, automatically splitting long responses into multiple messages to stay within Telegram's 4096 character limit. It also includes a typing indicator to show the bot is processing.

## Honcho Integration

The new Honcho peer/session API makes integration much simpler:

```python
peer = honcho_client.peer(id=get_peer_id_from_telegram(update))
session = honcho_client.session(id=str(update.effective_chat.id))
```

Here we create a peer object for the user and a session object using the Telegram chat ID. This automatically handles user and session management across both private chats and group conversations.

```python
# Save both the user's message and the bot's response to the session
session.add_messages(
    [
        peer.message(input_text),
        assistant.message(response),
    ]
)
```

After generating the response, we save both the user's input and the bot's response to the session using the `add_messages()` method. The `peer.message()` creates a message from the user, while `assistant.message()` creates a message from the assistant.

## Commands

Telegram bots support slash commands natively. Here's how to implement the `/dialectic` command using Honcho's dialectic feature:

```python
async def dialectic_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """
    Handle the /dialectic command to query the Honcho Dialectic endpoint.
    """
    if not context.args:
        await update.message.reply_text(
            "Please provide a query. Usage: /dialectic <your query>"
        )
        return

    query = " ".join(context.args)

    try:
        peer = honcho_client.peer(id=get_peer_id_from_telegram(update))
        session = honcho_client.session(id=str(update.effective_chat.id))

        response = peer.chat(
            query=query,
            session_id=session.id,
        )

        if response:
            await send_telegram_message(update, context, response)
        else:
            await update.message.reply_text(
                f"I don't know anything about {update.effective_user.first_name} because we haven't talked yet!"
            )
    except Exception as e:
        logger.error(f"Error calling Dialectic API: {e}")
        await update.message.reply_text(
            f"Sorry, there was an error processing your request: {str(e)}"
        )
```

You can also add a `/start` command for user onboarding:

```python
async def start_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Handle the /start command"""
    await update.message.reply_text(
        "Hello! I'm your AI assistant. You can:\n"
        "• Chat with me directly in private messages\n"
        "• Mention me (@username) in groups to get my attention\n"
        "• Use /dialectic <query> to search our conversation history\n\n"
        "Let's start chatting!"
    )
```

## Setup and Configuration

The bot requires several environment variables and setup:

```python
honcho_client = Honcho()
assistant = honcho_client.peer(id="assistant", config={"observe_me": False})
openai = OpenAI(base_url="https://openrouter.ai/api/v1", api_key=MODEL_API_KEY)
```

* `honcho_client`: The main Honcho client
* `assistant`: A peer representing the bot/assistant
* `openai`: OpenAI client configured to use OpenRouter

### Application Setup

Register your handlers with the Telegram application:

```python
def main():
    """Start the bot"""
    if not BOT_TOKEN:
        logger.error("BOT_TOKEN not found in environment variables")
        return

    # Create the Application
    application = Application.builder().token(BOT_TOKEN).build()

    # Add handlers
    application.add_handler(CommandHandler("start", start_command))
    application.add_handler(CommandHandler("dialectic", dialectic_command))
    application.add_handler(
        MessageHandler(filters.TEXT & ~filters.COMMAND, handle_message)
    )

    # Start the bot
    logger.info("Starting Telegram bot...")
    application.run_polling(allowed_updates=Update.ALL_TYPES)
```

## Environment Variables

Your bot needs these environment variables:

```env
# Your Telegram bot token from BotFather
BOT_TOKEN=<your-token>

# AI model to use (see OpenRouter for available models)
MODEL_NAME=<your-model>

# Your OpenRouter API key
MODEL_API_KEY=<your-openrouter-api-key>
```

## Chat Types and Behavior

The bot handles different Telegram chat types intelligently:

### Private Chats

* **Behavior**: Responds to all messages
* **Session ID**: Uses the private chat ID
* **Memory**: Maintains conversation history per user

### Group Chats

* **Behavior**: Only responds when mentioned or replied to
* **Session ID**: Uses the group chat ID (shared across all members)
* **Memory**: Maintains group conversation context

## Recap

The new Honcho peer/session API makes Telegram bot integration much simpler and more intuitive. Key patterns we learned:

* **Peer/Session Model**: Users are represented as peers, conversations as sessions
* **Chat Type Handling**: Different validation logic for private vs group chats
* **Automatic Context Management**: `session.get_context().to_openai()` automatically formats chat history
* **Message Storage**: `session.add_messages()` stores both user and assistant messages
* **Dialectic Queries**: `peer.chat()` enables querying conversation history
* **Command System**: Native Telegram command support with `/start` and `/dialectic`
* **Message Splitting**: Automatic handling of Telegram's character limits
* **Helper Functions**: Clean code organization with focused helper functions

This approach provides a clean, maintainable structure for building Telegram bots with conversational memory and context management across both private conversations and group chats.


# Using Filters
Source: https://docs.honcho.dev/v2/guides/using-filters

Learn how to filter workspaces, peers, sessions, and messages using Honcho's powerful filtering system

Honcho provides a sophisticated filtering system that allows you to query workspaces, peers, sessions, and messages with precise control. The filtering system supports logical operators, comparison operators, metadata filtering, and wildcards to help you find exactly what you need.

## Basic Filtering Concepts

Filters in Honcho are expressed as dictionaries that define conditions for matching resources. The system supports both simple equality filters and complex queries with multiple conditions.

### Simple Filters

The most basic filters check for exact matches:

<CodeGroup>
  ```python Python
  from honcho import Honcho

  # Initialize client
  honcho = Honcho()

  # Simple peer filter
  peers = honcho.get_peers(filters={"peer_id": "alice"})

  # Simple session filter with metadata
  sessions = honcho.get_sessions(filters={
      "metadata": {"type": "support"}
  })

  # Simple message filter
  messages = honcho.get_messages(filters={
      "session_id": "support-chat-1",
      "peer_id": "alice"
  })
  ```

  ```typescript TypeScript
  import { Honcho } from "@honcho-ai/sdk";

  (async () => {
      // Initialize client
      const honcho = new Honcho({});

      // Simple peer filter
      const peers = await honcho.getPeers({
        filters: { peerId: "alice" }
      });

      // Simple session filter with metadata
      const sessions = await honcho.getSessions({
        filters: {
          metadata: { type: "support" }
        }
      });

      // Simple message filter
      const messages = await honcho.getMessages({
        filters: {
          sessionId: "support-chat-1",
          peerId: "alice"
        }
      });
  })();
  ```
</CodeGroup>

## Logical Operators

Combine multiple conditions using logical operators for complex queries:

### AND Operator

Use AND to require all conditions to be true:

<CodeGroup>
  ```python Python
  messages = honcho.get_messages(filters={
      "AND": [
          {"session_id": "chat-1"},
          {"created_at": {"gte": "2024-01-01"}}
      ]
  })
  ```

  ```typescript TypeScript
  (async () => {
      const messages = await honcho.getMessages({
        filters: {
          AND: [
            { sessionId: "chat-1" },
            { createdAt: { gte: "2024-01-01" } }
          ]
        }
      });
  })();
  ```
</CodeGroup>

### OR Operator

Use OR to match any of the specified conditions:

<CodeGroup>
  ```python Python
  # Find messages from either alice or bob
  messages = session.get_messages(filters={
      "OR": [
          {"peer_id": "alice"},
          {"peer_id": "bob"}
      ]
  })

  # Complex OR with metadata conditions
  sessions = honcho.get_sessions(filters={
      "OR": [
          {"metadata": {"priority": "high"}},
          {"metadata": {"urgent": True}},
          {"metadata": {"escalated": True}}
      ]
  })
  ```

  ```typescript TypeScript
  (async () => {
      // Find messages from either alice or bob
      const messages = await session.getMessages({
        filters: {
          OR: [
            { peerId: "alice" },
            { peerId: "bob" }
          ]
        }
      });

      // Complex OR with metadata conditions
      const sessions = await honcho.getSessions({
        filters: {
          OR: [
            { metadata: { priority: "high" } },
            { metadata: { urgent: true } },
            { metadata: { escalated: true } }
          ]
        }
      });
  })();
  ```
</CodeGroup>

### NOT Operator

Use NOT to exclude specific conditions:

<CodeGroup>
  ```python Python
  # Find all peers except alice
  peers = honcho.get_peers(filters={
      "NOT": [
          {"peer_id": "alice"}
      ]
  })

  # Find sessions that are NOT completed
  sessions = honcho.get_sessions(filters={
      "NOT": [
          {"metadata": {"status": "completed"}}
      ]
  })
  ```

  ```typescript TypeScript
  (async () => {
      // Find all peers except alice
      const peers = await honcho.getPeers({
        filters: {
          NOT: [
            { peerId: "alice" }
          ]
        }
      });

      // Find sessions that are NOT completed
      const sessions = await honcho.getSessions({
        filters: {
          NOT: [
            { metadata: { status: "completed" } }
          ]
        }
      });
  })();
  ```
</CodeGroup>

### Combining Logical Operators

Create sophisticated queries by combining different logical operators:

<CodeGroup>
  ```python Python
  # Find messages from alice OR bob, but NOT where message has archived set to true in metadata
  messages = session.get_messages(filters={
      "AND": [
          {
              "OR": [
                  {"peer_id": "alice"},
                  {"peer_id": "bob"}
              ]
          },
          {
              "NOT": [
                  {"metadata": {"archived": True}}
              ]
          }
      ]
  })
  ```

  ```typescript TypeScript
  (async () => {
      // Find messages from alice OR bob, but NOT where message has archived set to true in metadata
      const messages = await session.getMessages({
        filters: {
          AND: [
            {
              OR: [
                { peerId: "alice" },
                { peerId: "bob" }
              ]
            },
            {
              NOT: [
                { metadata: { archived: true } }
              ]
            }
          ]
        }
      });
  })();
  ```
</CodeGroup>

## Comparison Operators

Use comparison operators for range queries and advanced matching:

### Numeric Comparisons

<CodeGroup>
  ```python Python
  # Find sessions created after a specific date
  sessions = honcho.get_sessions(filters={
      "created_at": {"gte": "2024-01-01"}
  })

  # Find messages within a date range
  messages = session.get_messages(filters={
      "created_at": {
          "gte": "2024-01-01",
          "lte": "2024-12-31"
      }
  })

  # Metadata numeric comparisons
  sessions = honcho.get_sessions(filters={
      "metadata": {
          "score": {"gt": 8.5},
          "duration": {"lte": 3600}
      }
  })
  ```

  ```typescript TypeScript
  (async () => {
      // Find sessions created after a specific date
      const sessions = await honcho.getSessions({
        filters: {
          createdAt: { gte: "2024-01-01" }
        }
      });

      // Find messages within a date range
      const messages = await session.getMessages({
        filters: {
          createdAt: {
            gte: "2024-01-01",
            lte: "2024-12-31"
          }
        }
      });

      // Metadata numeric comparisons
      const sessions = await honcho.getSessions({
        filters: {
          metadata: {
            score: { gt: 8.5 },
            duration: { lte: 3600 }
          }
        }
      });
  })();
  ```
</CodeGroup>

### List Membership

<CodeGroup>
  ```python Python
  # Find messages from specific peers in a session
  messages = session.get_messages(filters={
      "peer_id": {"in": ["alice", "bob", "charlie"]}
  })

  # Find sessions with specific tags
  sessions = honcho.get_sessions(filters={
      "metadata": {
          "tag": {"in": ["important", "urgent", "follow-up"]}
      }
  })

  # Not equal comparisons
  peers = honcho.get_peers(filters={
      "metadata": {
          "status": {"ne": "inactive"}
      }
  })
  ```

  ```typescript TypeScript
  (async () => {
      // Find messages from specific peers in a session
      const messages = await session.getMessages({
        filters: {
          peerId: { in: ["alice", "bob", "charlie"] }
        }
      });

      // Find sessions with specific tags
      const sessions = await honcho.getSessions({
        filters: {
          metadata: {
            tag: { in: ["important", "urgent", "follow-up"] }
          }
        }
      });

      // Not equal comparisons
      const peers = await honcho.getPeers({
        filters: {
          metadata: {
            status: { ne: "inactive" }
          }
        }
      });
  })();
  ```
</CodeGroup>

## Metadata Filtering

Metadata filtering is particularly powerful in Honcho, supporting nested conditions and complex queries:

### Basic Metadata Filtering

<CodeGroup>
  ```python Python
  # Simple metadata equality
  sessions = honcho.get_sessions(filters={
      "metadata": {
          "type": "customer_support",
          "priority": "high"
      }
  })

  # Nested metadata objects
  peers = honcho.get_peers(filters={
      "metadata": {
          "profile": {
              "role": "admin",
              "department": "engineering"
          }
      }
  })
  ```

  ```typescript TypeScript
  (async () => {
      // Simple metadata equality
      const sessions = await honcho.getSessions({
        filters: {
          metadata: {
            type: "customer_support",
            priority: "high"
          }
        }
      });

      // Nested metadata objects
      const peers = await honcho.getPeers({
        filters: {
          metadata: {
            profile: {
              role: "admin",
              department: "engineering"
            }
          }
        }
      });
  })();
  ```
</CodeGroup>

### Advanced Metadata Queries

<Info>
  If you want to do advanced queries like these, make sure not to create metadata fields that use the same names as the included comparison operators! For example, if you have a metadata field called `contains`, it will conflict with the `contains` operator.
</Info>

<CodeGroup>
  ```python Python
  # Metadata with comparison operators
  sessions = honcho.get_sessions(filters={
      "metadata": {
          "score": {"gte": 4.0, "lte": 5.0},
          "created_by": {"ne": "system"},
          "tags": {"contains": "important"}
      }
  })

  # Complex metadata conditions
  messages = session.get_messages(filters={
      "AND": [
          {"metadata": {"sentiment": {"in": ["positive", "neutral"]}}},
          {"metadata": {"confidence": {"gt": 0.8}}},
          {"content": {"icontains": "thank"}}
      ]
  })
  ```

  ```typescript TypeScript
  (async () => {
      // Metadata with comparison operators
      const sessions = await honcho.getSessions({
        filters: {
          metadata: {
            score: { gte: 4.0, lte: 5.0 },
            createdBy: { ne: "system" },
            tags: { contains: "important" }
          }
        }
      });

      // Complex metadata conditions
      const messages = await session.getMessages({
        filters: {
          AND: [
            { metadata: { sentiment: { in: ["positive", "neutral"] } } },
            { metadata: { confidence: { gt: 0.8 } } },
            { content: { icontains: "thank" } }
          ]
        }
      });
  })();
  ```
</CodeGroup>

## Wildcards

Use wildcards (\*) to match any value for a field:

<CodeGroup>
  ```python Python
  # Find all sessions with any peer_id (essentially all sessions)
  sessions = honcho.get_sessions(filters={
      "peer_id": "*"
  })

  # Wildcard in lists - matches everything
  messages = session.get_messages(filters={
      "peer_id": {"in": ["alice", "bob", "*"]}
  })

  # Metadata wildcards
  sessions = honcho.get_sessions(filters={
      "metadata": {
          "type": "*",  # Any type
          "status": "active"  # But status must be active
      }
  })
  ```

  ```typescript TypeScript
  (async () => {
      // Find all sessions with any peer_id (essentially all sessions)
      const sessions = await honcho.getSessions({
        filters: {
          peerId: "*"
        }
      });

      // Wildcard in lists - matches everything
      const messages = await session.getMessages({
        filters: {
          peerId: { in: ["alice", "bob", "*"] }
        }
      });

      // Metadata wildcards
      const sessions = await honcho.getSessions({
        filters: {
          metadata: {
            type: "*",  // Any type
            status: "active"  // But status must be active
          }
        }
      });
  })();
  ```
</CodeGroup>

## Resource-Specific Examples

### Filtering Workspaces

<CodeGroup>
  ```python Python
  # Find workspaces by name pattern
  workspaces = honcho.get_workspaces(filters={
      "name": {"contains": "prod"}
  })

  # Filter by metadata
  workspaces = honcho.get_workspaces(filters={
      "metadata": {
          "environment": "production",
          "team": {"in": ["backend", "frontend", "devops"]}
      }
  })
  ```

  ```typescript TypeScript
  (async () => {
      // Find workspaces by name pattern
      const workspaces = await honcho.getWorkspaces({
        filters: {
          name: { contains: "prod" }
        }
      });

      // Filter by metadata
      const workspaces = await honcho.getWorkspaces({
        filters: {
          metadata: {
            environment: "production",
            team: { in: ["backend", "frontend", "devops"] }
          }
        }
      });
  })();
  ```
</CodeGroup>

### Filtering Messages

<CodeGroup>
  ```python Python
  # Find error messages from the last week
  from datetime import datetime, timedelta

  week_ago = (datetime.now() - timedelta(days=7)).isoformat()
  messages = session.get_messages(filters={
      "AND": [
          {"content": {"icontains": "error"}},
          {"created_at": {"gte": week_ago}},
          {"metadata": {"level": {"in": ["error", "critical"]}}}
      ]
  })

  # Find messages in specific sessions with sentiment analysis
  messages = session.get_messages(filters={
      "AND": [
          {"session_id": {"in": ["support-1", "support-2", "support-3"]}},
          {"metadata": {"sentiment": "negative"}},
          {"metadata": {"confidence": {"gte": 0.7}}}
      ]
  })
  ```

  ```typescript TypeScript
  (async () => {
      // Find error messages from the last week
      const weekAgo = new Date(Date.now() - 7 * 24 * 60 * 60 * 1000).toISOString();
      const messages = await session.getMessages({
        filters: {
          AND: [
            { content: { icontains: "error" } },
            { createdAt: { gte: weekAgo } },
            { metadata: { level: { in: ["error", "critical"] } } }
          ]
        }
      });

      // Find messages in specific sessions with sentiment analysis
      const messages = await session.getMessages({
        filters: {
          AND: [
            { sessionId: { in: ["support-1", "support-2", "support-3"] } },
            { metadata: { sentiment: "negative" } },
            { metadata: { confidence: { gte: 0.7 } } }
          ]
        }
      });
  })();
  ```
</CodeGroup>

## Error Handling

Handle filter errors gracefully:

<CodeGroup>
  ```python Python
  from honcho.exceptions import FilterError

  try:
      # Invalid filter - unsupported operator
      messages = session.get_messages(filters={
          "created_at": {"invalid_operator": "2024-01-01"}
      })
  except FilterError as e:
      print(f"Filter error: {e}")
      # Handle the error appropriately

  try:
      # Invalid column name
      sessions = honcho.get_sessions(filters={
          "nonexistent_field": "value"
      })
  except FilterError as e:
      print(f"Invalid field: {e}")
  ```

  ```typescript TypeScript
  (async () => {
      try {
        // Invalid filter - unsupported operator
        const messages = await session.getMessages({
          filters: {
            createdAt: { invalidOperator: "2024-01-01" }
          }
        });
      } catch (error) {
        if (error.message.includes("filters")) {
          console.error(`Filter error: ${error.message}`);
          // Handle the error appropriately
        }
      }

      try {
        // Invalid column name
        const sessions = await honcho.getSessions({
          filters: {
            nonexistentField: "value"
          }
        });
      } catch (error) {
        console.error(`Invalid field: ${error.message}`);
      }
  })();
  ```
</CodeGroup>

## Conclusion

Honcho's filtering system provides powerful capabilities for querying your conversational data. By understanding how to:

* Use simple equality filters and complex logical operators
* Apply comparison operators for range and pattern matching
* Filter metadata with nested conditions
* Handle wildcards and dynamic filter construction
* Follow best practices for performance and validation

You can build sophisticated applications that efficiently find and process exactly the conversations, messages, and insights you need from your Honcho data.


# Working Representations
Source: https://docs.honcho.dev/v2/guides/working-rep

Learn how to retrieve cached peer knowledge and understanding using Honcho's working representation system

Working representations are Honcho's system for accessing cached psychological models that capture what peers know, think, and remember. Unlike the `chat()` method which generates fresh representations on-demand, the `working_rep()` method retrieves pre-computed representations that have been automatically built and stored as conversations progress.

## How Working Representations Are Created

Working representations are automatically generated and cached through Honcho's background processing system:

1. **Automatic Generation**: When messages are added to sessions, they trigger background jobs that analyze conversations using theory of mind inference and long-term memory integration

2. **Cached Storage**: The generated representations are stored in the database as metadata on `Peer` objects (for global representations) or `SessionPeer` objects (for session-scoped representations)

3. **Retrieval**: The `working_rep()` method provides fast access to these cached representations without requiring LLM processing

<Info>
  **Cached vs On-Demand**: `working_rep()` retrieves cached representations for fast access, while `peer.chat()` generates fresh representations using the dialectic system. Use `working_rep()` when you need fast access to stored knowledge, and `chat()` when you need current analysis with custom queries.
</Info>

## Basic Usage

Working representations are accessed through the `working_rep()` method on Session objects:

<CodeGroup>
  ```python Python
  from honcho import Honcho

  # Initialize client
  honcho = Honcho()

  # Create peers and session
  user = honcho.peer("user-123")
  assistant = honcho.peer("ai-assistant")
  session = honcho.session("support-conversation")

  # Add conversation to trigger representation generation
  session.add_messages([
      user.message("I'm having trouble with my billing account"),
      assistant.message("I can help with that. What specific issue are you seeing?"),
      user.message("My credit card was charged twice last month"),
      assistant.message("I see duplicate charges on your account. Let me refund one of them.")
  ])

  # Chat to generate a working representation
  response = user.chat("What is this user's main concern right now?", session_id=session.id)

  # Retrieve the cached working representation for the user
  user_representation = session.working_rep("user-123")
  print("Cached user representation:", user_representation)
  ```

  ```typescript TypeScript
  import { Honcho } from "@honcho-ai/sdk";

  // Initialize client
  const honcho = new Honcho({});

  // Create peers and session
  const user = await honcho.peer("user-123");
  const assistant = await honcho.peer("ai-assistant");
  const session = await honcho.session("support-conversation");

  // Add conversation to trigger representation generation
  await session.addMessages([
    user.message("I'm having trouble with my billing account"),
    assistant.message("I can help with that. What specific issue are you seeing?"),
    user.message("My credit card was charged twice last month"),
    assistant.message("I see duplicate charges on your account. Let me refund one of them.")
  ]);

  // Chat to generate a working representation
  const response = await user.chat("What is this user's main concern right now?", { sessionId: session.id });

  // Retrieve the cached working representation for the user
  const userRepresentation = await session.workingRep("user-123");
  console.log("Cached user representation:", userRepresentation);
  // Returns: { representation: Object }
  ```
</CodeGroup>

## Understanding Representation Content

Cached working representations contain structured psychological analysis based on conversation history. The format typically includes:

### Current Mental State Predictions

Information about what the peer is currently thinking, feeling, or focused on based on recent messages.

### Relevant Long-term Facts

Facts about the peer that have been extracted and stored over time from various conversations.

### Example Representation Structure

<CodeGroup>
  ```python Python
  # Example of what a cached representation might contain
  representation = session.working_rep("user-123")

  # Typical content structure:
  """
  PREDICTION ABOUT THE USER'S CURRENT MENTAL STATE:
  The user appears frustrated with a billing issue, specifically concerning duplicate charges.
  They seem to have some confidence in the support process as they provided specific details.

  RELEVANT LONG-TERM FACTS ABOUT THE USER:
  - User has had previous billing inquiries
  - User prefers direct, specific communication
  - User is detail-oriented when reporting issues
  """

  print("Full representation:", representation)
  ```

  ```typescript TypeScript
  // Example of what a cached representation might contain
  const representation = await session.workingRep("user-123");

  // Typical content structure:
  /*
  PREDICTION ABOUT THE USER'S CURRENT MENTAL STATE:
  The user appears frustrated with a billing issue, specifically concerning duplicate charges.
  They seem to have some confidence in the support process as they provided specific details.

  RELEVANT LONG-TERM FACTS ABOUT THE USER:
  - User has had previous billing inquiries
  - User prefers direct, specific communication
  - User is detail-oriented when reporting issues
  */

  console.log("Full representation:", representation);
  ```
</CodeGroup>

## When Representations Are Updated

Working representations are automatically updated through Honcho's background processing system:

### Message Processing Pipeline

1. **Message Creation**: When messages are added via `session.add_messages()` or similar methods
2. **Background Queuing**: Messages are queued for processing in the background
3. **Theory of Mind Analysis**: The system analyzes conversation patterns and psychological states
4. **Fact Extraction**: Long-term facts are extracted and stored in vector embeddings
5. **Representation Generation**: New representations are created combining current analysis with historical facts
6. **Cache Update**: The new representation is stored in the database metadata

### Processing Triggers

Representations are updated when:

* New messages are added to sessions
* Sufficient new content has accumulated
* The background processing system determines an update is needed

## Comparison with Chat Method

Understanding when to use `working_rep()` vs `peer.chat()`:

### Use `working_rep()` when:

* You need fast access to stored psychological models
* You want to see what the system has already learned about a peer
* You're building dashboards or analytics that display peer understanding
* You need consistent representations that don't change between calls

### Use `peer.chat()` when:

* You need to ask specific questions about a peer
* You want fresh analysis based on current conversation state
* You need customized insights for specific use cases
* You want to query about relationships between peers

<CodeGroup>
  ```python Python
  # Fast cached access
  cached_rep = session.working_rep("user-123")
  print("Cached:", cached_rep[:100] + "...")

  # Custom query with fresh analysis
  custom_analysis = user.chat("What is this user's main concern right now?", session_id=session.id)
  print("Fresh analysis:", custom_analysis)
  ```

  ```typescript TypeScript
  // Fast cached access
  const cachedRep = await session.workingRep("user-123");
  console.log("Cached:", cachedRep.substring(0, 100) + "...");

  // Custom query with fresh analysis
  const customAnalysis = await user.chat("What is this user's main concern right now?", { sessionId: session.id });
  console.log("Fresh analysis:", customAnalysis);
  ```
</CodeGroup>

## Best Practices

### 1. Ensure Availability Before Using

Make sure that a representation exists before processing it by using the chat endpoint first.

### 2. Use for Fast Analytics

Cached representations are ideal for analytics dashboards:

<CodeGroup>
  ```python Python
  # Good: Fast dashboard updates using cached data
  def update_analytics_dashboard(sessions):
      analytics = {}
      for session in sessions:
          for peer_id in session.get_peer_ids():
              rep = session.working_rep(peer_id)
              analytics[peer_id] = analyze_representation(rep)
      return analytics
  ```

  ```typescript TypeScript
  // Good: Fast dashboard updates using cached data
  async function updateAnalyticsDashboard(sessions) {
    const analytics: Record<string, any> = {};
    for (const session of sessions) {
      const peerIds = await session.getPeerIds();
      for (const peerId of peerIds) {
        const rep = await session.workingRep(peerId);
        analytics[peerId] = analyzeRepresentation(rep);
      }
    }
    return analytics;
  }
  ```
</CodeGroup>

### 3. Combine with Fresh Analysis When Needed

Use cached representations for baseline understanding, and fresh analysis for current insights:

<CodeGroup>
  ```python Python
  # Get baseline understanding from cache
  baseline = session.working_rep("user-123")

  # Get current specific insights
  current_state = user.chat("How is this user feeling right now?", session_id=session.id)

  # Combine for comprehensive view
  comprehensive_view = {
      "baseline_knowledge": baseline,
      "current_analysis": current_state
  }
  ```

  ```typescript TypeScript
  // Get baseline understanding from cache
  const baseline = await session.workingRep("user-123");

  // Get current specific insights
  const currentState = await user.chat("How is this user feeling right now?", { sessionId: session.id });

  // Combine for comprehensive view
  const comprehensiveView = {
    baselineKnowledge: baseline,
    currentAnalysis: currentState
  };
  ```
</CodeGroup>

## Conclusion

Working representations provide fast access to cached psychological models that Honcho automatically builds and maintains. By understanding how to:

* Retrieve cached representations using `session.working_rep()`
* Parse and interpret representation content
* Handle cases where representations aren't available
* Combine cached and fresh analysis appropriately

You can build efficient applications that leverage Honcho's continuous learning about peer knowledge and mental states without the latency of real-time generation.
